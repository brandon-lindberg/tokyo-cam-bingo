<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Tokyo Cam Bingo</title>

  <!-- PWA Meta Tags -->
  <meta name="description" content="Play bingo while watching Tokyo live streams with friends">
  <meta name="theme-color" content="#FF69B4">
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="manifest" href="/site.webmanifest">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="TCB">

  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@500&family=Roboto&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="/css/styles.css?v=<%= assetVersion %>">
  <script src="/js/pwa-install.js?v=<%= assetVersion %>" defer></script>
  <script src="/socket.io/socket.io.js"></script>
  <script src="/js/timer.js?v=<%= assetVersion %>"></script>
  <script src="/js/game.js?v=<%= assetVersion %>"></script>
</head>
<body class="game-page" data-game-id="<%= game.id %>" data-player-id="<%= currentPlayer.id %>" data-player-name="<%= currentPlayer.name %>" data-is-host="<%= currentPlayer.isHost %>" data-game-status="<%= game.status %>" data-game-mode="<%= game.mode %>" data-flags-enabled="<%= game.flagsEnabled %>" data-rerolls-enabled="<%= game.rerollsEnabled %>" data-player-color="<%= currentPlayer.color || '' %>" data-asset-version="<%= assetVersion %>" data-sw-enabled="<%= enableServiceWorker %>" data-timer-enabled="<%= game.timerEnabled %>" data-timer-duration="<%= game.timerDuration || 0 %>" data-timer-status="<%= game.timerStatus || 'not_started' %>" data-timer-started-at="<%= game.timerStartedAt ? game.timerStartedAt.toISOString() : '' %>">
<aside class="sidebar">
  <div class="sidebar-header">
    <div class="copy-code-wrapper">
      <button onclick="copyGameCode()">Copy Code</button>
      <span id="copy-confirm" style="display:block;margin-top:0.25rem;color:#4CAF50;visibility:hidden;">Code copied!</span>
    </div>
    <div class="chat-icon-wrapper">
      <div style="position: relative; display: inline-block;">
        <button id="chat-toggle-desktop" class="chat-toggle-button">
          <svg width="24" height="24" fill="currentColor" viewBox="0 0 24 24"><path d="M2 2h20v18l-4-4H2V2z"/></svg>
        </button>
        <span id="chat-notification" class="notification-badge"></span>
      </div>
      <% if (game.flagsEnabled) { %>
        <button id="flag-button" class="chat-toggle-button" title="Throw Flag">🚩</button>
      <% } %>
    </div>
  </div>

  <!-- Timer Display (Desktop) -->
  <% if (game.timerEnabled) { %>
    <div class="timer-display-section">
      <div class="timer-display-info">
        <div id="game-timer" class="game-timer">
          <div class="timer-value" id="timer-value">--:--</div>
        </div>
      </div>
      <% if (currentPlayer.isHost) { %>
        <div class="timer-controls timer-controls-desktop">
          <button id="start-timer-btn" class="timer-control-btn timer-start-btn" onclick="startTimer()" style="display: block;">Start Game</button>
          <button id="pause-timer-btn" class="timer-control-btn timer-pause-btn" onclick="pauseTimer()" style="display: none;">Pause</button>
          <button id="resume-timer-btn" class="timer-control-btn timer-resume-btn" onclick="resumeTimer()" style="display: none;">Resume</button>
          <button id="reset-timer-btn" class="timer-control-btn timer-reset-btn" onclick="resetTimer()" style="display: none;">Reset</button>
        </div>
      <% } %>
    </div>
  <% } %>

  <div class="leaderboard-section">
    <table id="leaderboard">
      <thead>
        <tr>
          <th>Rank</th>
          <th>Player</th>
          <th>Lines</th>
          <th>Stamped Tiles</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
  </div>
  <% if (currentPlayer.isHost && game.rerollsEnabled) { %>
    <div class="reroll-section">
      <div class="reroll-controls">
        <button onclick="enterRerollMode('<%= currentPlayer.id %>')">Enter Re-roll Mode</button>
        <div id="reroll-mode-<%= currentPlayer.id %>" style="display:none;">
          <select id="reroll-type-<%= currentPlayer.id %>" onchange="handleTypeChange('<%= currentPlayer.id %>')">
            <option value="">Select Type</option>
            <option value="tile">Tile</option>
            <option value="row">Row</option>
            <option value="column">Column</option>
            <option value="diagonal">Diagonal</option>
            <option value="card">Whole Card</option>
            <option value="random">Random Tile</option>
            <option value="random_row">Random Row</option>
            <option value="random_column">Random Column</option>
            <option value="random_diagonal">Random Diagonal</option>
          </select>
          <p id="selection-instruct-<%= currentPlayer.id %>">Click on the card to select the area.</p>
          <button id="select-random-button-<%= currentPlayer.id %>" style="display:none;" onclick="selectRandomTile('<%= currentPlayer.id %>')">Select Random Tile</button>
          <button onclick="confirmReroll('<%= currentPlayer.id %>')">Confirm Re-roll</button>
          <button onclick="exitRerollMode('<%= currentPlayer.id %>')">Cancel</button>
        </div>
      </div>
      <button id="streamer-toggle-btn" onclick="toggleStreamerMode()">Streamer Mode: Off</button>
    </div>
  <% } %>
  <% if (!currentPlayer.isHost) { %>
    <div class="nonhost-streamer-section">
      <button id="streamer-toggle-btn-nonhost" onclick="toggleStreamerModeNonHost()">Streamer Mode: Off</button>
    </div>
  <% } %>
</aside>
  <div class="container">
    <div class="game-header">
    <h1 style="font-size: 0.9rem; margin-top: 1rem;">Win Conditions: <%= game.rules.winConditions && game.rules.winConditions.length > 0 ? game.rules.winConditions.map(c => {
      // Replace underscores with spaces and format properly
      let formatted = c.replace(/_/g, ' ');
      // Handle special cases
      if (formatted.includes('rows')) formatted = formatted.replace('rows', ' Rows');
      else if (formatted.includes('columns')) formatted = formatted.replace('columns', ' Columns');
      // Capitalize first letter
      return formatted.charAt(0).toUpperCase() + formatted.slice(1);
    }).join(', ') : 'None' %></h1>

    <!-- Timer Display (Mobile) -->
  <% if (game.timerEnabled) { %>
    <div class="timer-display-mobile mobile-only">
      <div class="timer-display-info">
        <div id="game-timer-mobile" class="game-timer game-timer-mobile">
          <div class="timer-value" id="timer-value-mobile">--:--</div>
        </div>
      </div>
      <% if (currentPlayer.isHost) { %>
        <div class="timer-controls timer-controls-mobile">
          <button id="start-timer-btn-mobile" class="timer-control-btn timer-start-btn" onclick="startTimer()">Start Game</button>
          <button id="pause-timer-btn-mobile" class="timer-control-btn timer-pause-btn" onclick="pauseTimer()" style="display: none;">Pause</button>
            <button id="resume-timer-btn-mobile" class="timer-control-btn timer-resume-btn" onclick="resumeTimer()" style="display: none;">Resume</button>
            <button id="reset-timer-btn-mobile" class="timer-control-btn timer-reset-btn" onclick="resetTimer()" style="display: none;">Reset</button>
          </div>
        <% } %>
      </div>
    <% } %>

    <!-- header-controls removed in favor of sidebar -->
  </div>

    <div class="game-layout">
      <div class="card-section">
        <table id="card-<%= currentPlayer.id %>" class="bingo-card <%= game.mode === 'VS' ? 'vs-card' : 'own-card' %>">
          <% currentPlayer.card.forEach((row, r) => { %>
            <tr>
              <% row.forEach((tile, c) => { %>
                <td class="<%= tile.stamped ? 'stamped' : '' %>" data-row="<%= r %>" data-col="<%= c %>">
                  <div class="tile-content"><%= tile.item %></div>
                </td>
              <% }) %>
            </tr>
          <% }) %>
        </table>
        
        <!-- Original host reroll controls removed here -->
      </div>
      
      <!-- original leaderboard-section removed in favor of sidebar -->
    </div>
  </div>

  <!-- Bottom App Bar for Mobile -->
  <div class="bottom-app-bar mobile-only">
    <button onclick="toggleDrawer('leaderboard')">Leaderboard</button>
    <div class="bottom-app-bar-item">
      <button id="chat-toggle-mobile" class="chat-toggle-button">
        <svg width="24" height="24" fill="currentColor" viewBox="0 0 24 24"><path d="M2 2h20v18l-4-4H2V2z"/></svg>
      </button>
      <span id="chat-notification-mobile" class="notification-badge"></span>
    </div>
    <% if (game.flagsEnabled) { %>
      <button id="flag-button-mobile" class="chat-toggle-button" title="Throw Flag">🚩</button>
    <% } %>
    <% if (currentPlayer.isHost) { %>
      <button id="copy-code-mobile" onclick="copyGameCode()" title="Copy Game Code">Copy Code</button>
    <% } %>
  </div>
  <!-- Centered mobile toast for copy code -->
  <div id="copy-toast-mobile" class="mobile-only" style="display:none;">Code copied!</div>
  <!-- Hidden input used for Safari execCommand copy fallback -->
  <input id="hidden-copy-input" type="text" readonly style="position:fixed; top:-1000px; left:-1000px; opacity:0; pointer-events:none;" />

  <!-- Slide-up Drawer -->
  <div id="drawer" class="drawer">
    <div class="drawer-content">
      <!-- Content populated dynamically -->
    </div>
    <button class="close-drawer" onclick="closeDrawer()">Close</button>
  </div>

  <!-- Winner Modal -->
  <div id="winner-modal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.5); align-items:center; justify-content:center; z-index:1001;">
    <div style="background:#fff; padding:2rem; border-radius:8px; text-align:center; max-width:90%; margin:auto;">
      <h2 id="winner-modal-name" style="color: #10B981; margin-bottom: 0.5rem; font-size: 2rem;">Winner!</h2>
      <p id="winner-modal-condition" style="font-size: 1.2rem; margin-bottom: 1.5rem; color: #333;">Win Condition</p>
      <div id="winner-modal-buttons" style="display: flex; gap: 1rem; justify-content: center; flex-wrap: wrap;">
        <% if (currentPlayer.isHost) { %>
          <button onclick="startNewGame()" style="padding: 0.75rem 1.5rem; font-size: 1rem; background-color: #00BFFF; color: white; border: none; border-radius: 8px; cursor: pointer;">Start New Game</button>
        <% } %>
        <button onclick="location.href = '/'" style="padding: 0.75rem 1.5rem; font-size: 1rem; background-color: #FF69B4; color: white; border: none; border-radius: 8px; cursor: pointer;">Exit to Home</button>
      </div>
    </div>
  </div>

  <!-- Timer Expired Modal -->
  <div id="timer-expired-modal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.6); align-items:center; justify-content:center; z-index:1002;">
    <div style="background:#fff; padding:2rem; border-radius:12px; text-align:center; max-width:90%; margin:auto; box-shadow: 0 8px 24px rgba(0,0,0,0.3);">
      <div style="font-size: 3rem; margin-bottom: 1rem;">⏰</div>
      <h2 id="timer-expired-title" style="color: #F59E0B; margin-bottom: 0.5rem; font-size: 2rem;">Time's Up!</h2>
      <p id="timer-expired-message" style="font-size: 1.1rem; margin-bottom: 1rem; color: #666;">The timer has expired.</p>
      <p id="timer-expired-winner" style="font-size: 1.3rem; font-weight: 600; margin-bottom: 1.5rem; color: #10B981; display: none;">Winner: Player Name</p>
      <div style="display: flex; gap: 1rem; justify-content: center; flex-wrap: wrap;">
        <% if (currentPlayer.isHost) { %>
          <button onclick="startNewGame(); closeTimerExpiredModal();" style="padding: 0.75rem 1.5rem; font-size: 1rem; background-color: #00BFFF; color: white; border: none; border-radius: 8px; cursor: pointer;">Start New Game</button>
        <% } %>
        <button onclick="location.href = '/'" style="padding: 0.75rem 1.5rem; font-size: 1rem; background-color: #FF69B4; color: white; border: none; border-radius: 8px; cursor: pointer;">Exit to Home</button>
      </div>
    </div>
  </div>
  <!-- Modal for opponent cards -->
  <div id="player-modal" style="display: none; position: fixed; z-index: 1; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.4);">
    <div class="modal-content" style="background-color: #fefefe; margin: 15% auto; padding: 20px; border: 1px solid #888; width: 80%; max-width: 800px;">
      <span onclick="closeModal()" style="cursor: pointer; float: right; font-size: 28px;">×</span>
      <h2 id="modal-player-name"></h2>
      <table id="modal-card" class="bingo-card"></table>
      <div id="modal-reroll" style="display: none;">
        <h3>Re-roll</h3>
        <select id="modal-reroll-type">
          <option value="">Select Type</option>
          <option value="tile">Tile</option>
          <option value="row">Row</option>
          <option value="column">Column</option>
          <option value="diagonal">Diagonal</option>
          <option value="card">Whole Card</option>
          <option value="random">Random Tile</option>
          <option value="random_row">Random Row</option>
          <option value="random_column">Random Column</option>
          <option value="random_diagonal">Random Diagonal</option>
        </select>
        <p id="modal-selection-instruct">Click on the card to select the area.</p>
        <button id="select-random-modal-button" style="display:none;" onclick="selectModalRandomTile()">Select Random Tile</button>
        <button id="modal-confirm-reroll">Confirm Re-roll</button>
        <button onclick="exitModalReroll()">Cancel</button>
      </div>
    </div>
  </div>
  
  <!-- Vote Modal -->
  <div id="vote-modal" class="modal-overlay" style="display:none;">
    <div class="modal-card">
      <div class="modal-header">
        <span style="font-size:1.25rem;">🚩</span>
        <h3 id="vote-modal-text" class="modal-title">Vote on Flagged Stamp</h3>
      </div>
      <p id="vote-modal-message" class="modal-subtitle"></p>
      <div id="vote-buttons" class="modal-actions">
        <button id="vote-yes" class="btn btn-primary">Yes</button>
        <button id="vote-no" class="btn btn-danger">No</button>
      </div>
      <div class="badges">
        <span class="badge" id="vote-count">Votes: 0 yes, 0 no</span>
      </div>
      <div id="vote-result" class="modal-footer" style="display:none;">
        <p id="vote-outcome" class="modal-subtitle" style="margin-bottom:0.5rem;"></p>
        <ul id="vote-details" class="vote-list"></ul>
        <div class="modal-actions">
          <button id="vote-close" class="btn btn-secondary">Close</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Flag Select Modal -->
  <div id="flag-select-modal" class="modal-overlay" style="display:none;">
    <div class="modal-card">
      <div class="modal-header">
        <span style="font-size:1.25rem;">🚩</span>
        <h3 class="modal-title">Throw Flag</h3>
      </div>
      <p class="modal-subtitle">Select a player to challenge:</p>
      <select id="flag-target-select">
        <option value="">-- Choose Player --</option>
      </select>
      <div class="modal-actions">
        <button id="flag-confirm" class="btn btn-primary">Confirm</button>
        <button id="flag-cancel" class="btn btn-secondary">Cancel</button>
      </div>
    </div>
  </div>
  
  <div id="chat-panel" class="chat-panel">
    <div class="chat-header">
      <h2>Chat</h2>
      <button id="chat-close-desktop">&times;</button>
    </div>
    <div id="chat-messages" class="chat-messages"></div>
    <div class="chat-input">
      <input id="chat-input" type="text" maxlength="300" placeholder="Type a message..." />
      <button id="chat-send">Send</button>
    </div>
  </div>
  
  <script id="chat-data" type="application/json"><%- JSON.stringify({ players, messages }) %></script>
  <script>
    // Clear any cached data to prevent stale game states
    (function() {
      try {
        // Don't clear storage on game page as it might affect sessions
        // Just ensure we're loading fresh data from server
      } catch (e) {
        console.warn('Storage check failed:', e);
      }
    })();

    const socket = io();
    window.socket = socket;
    const gameId = document.body.dataset.gameId;
    const playerId = document.body.dataset.playerId;
    const playerName = document.body.dataset.playerName;
    const isHost = document.body.dataset.isHost === 'true';

    // Initialize game timer if enabled
    let gameTimer = null;
    if (window.GameTimer) {
      gameTimer = new GameTimer(socket);
      window.gameTimer = gameTimer;
    }
    const gameMode = document.body.dataset.gameMode;
    const flagsEnabled = document.body.dataset.flagsEnabled === 'true';
    const rerollsEnabled = document.body.dataset.rerollsEnabled === 'true';
    const playerColor = document.body.dataset.playerColor;
    let isGameOver = document.body.dataset.gameStatus === 'ended';
    let allPlayers = []; // Global to store all players
    let modalOpenPlayerId = null; // Track open modal player
    // Preload game code for host to allow synchronous copy on Safari
    window.gameCode = null;
    if (isHost) {
      fetch('/get-code').then(r => r.ok ? r.text() : '').then(code => { window.gameCode = code || null; });
    }
    socket.emit('join_room', { gameId, playerId });

    // Update state
    socket.on('update_state', (data) => {
      const { game, players } = data;
      allPlayers = players; // Update global
      document.body.dataset.timerEnabled = game.timerEnabled ? 'true' : 'false';
      document.body.dataset.timerDuration = (game.timerDuration || 0).toString();
      document.body.dataset.timerStatus = game.timerStatus || 'not_started';
      document.body.dataset.timerStartedAt = game.timerStartedAt ? new Date(game.timerStartedAt).toISOString() : '';
      if (window.gameTimer) {
        window.gameTimer.syncWithGame(game);
      }
      const currentCardTable = document.getElementById(`card-${playerId}`);
      const currentPlayerData = players.find(p => p.id === playerId);

      if (currentPlayerData) {
        if (game.mode === 'VS') {
          // VS Mode: Update colored stamps based on all players
          currentPlayerData.card.forEach((row, r) => {
            row.forEach((tile, c) => {
              const td = currentCardTable.rows[r].cells[c];
              td.querySelector('.tile-content').textContent = tile.item;

              // Clear all stamp classes
              td.className = '';
              td.dataset.row = r;
              td.dataset.col = c;

              // Check which player (if any) has stamped this square
              let stampedBy = null;
              for (const player of players) {
                const squares = player.stampedSquares || [];
                if (squares.some(s => s.row === r && s.col === c)) {
                  stampedBy = player.color;
                  break;
                }
              }

              if (stampedBy) {
                td.classList.add(`stamped-${stampedBy}`);
              }
            });
          });
        } else {
          // Regular mode: Original stamping logic
          currentPlayerData.card.forEach((row, r) => {
            row.forEach((tile, c) => {
              const td = currentCardTable.rows[r].cells[c];
              td.querySelector('.tile-content').textContent = tile.item;
              td.classList.toggle('stamped', tile.stamped);
            });
          });
        }
      }
      updateLeaderboard(players, game.mode);
      // If mobile drawer leaderboard is open, refresh it
      if (document.getElementById('drawer-leaderboard')) {
        updateDrawerLeaderboard(players, game.mode);
      }
      
      if (game.status === 'ended' && !isGameOver) {
        isGameOver = true;
        document.getElementById('game-over').style.display = 'block';
        document.getElementById('winner-name').textContent = game.winner;
        if (isHost) {
          document.getElementById('host-options').style.display = 'block';
        }
      } else if (game.status === 'active' && isGameOver) {
        isGameOver = false;
        document.getElementById('game-over').style.display = 'none';
        if (isHost) {
          document.getElementById('host-options').style.display = 'none';
        }
      }

      // Update modal if open
      if (modalOpenPlayerId) {
        const updatedPlayer = players.find(p => p.id === modalOpenPlayerId);
        if (updatedPlayer) {
          const modalCard = document.getElementById('modal-card');
          modalCard.innerHTML = '';
          updatedPlayer.card.forEach((row, r) => {
            const tr = document.createElement('tr');
            row.forEach((tile, c) => {
              const td = document.createElement('td');
              const div = document.createElement('div');
              div.className = 'tile-content';
              div.textContent = tile.item;
              td.appendChild(div);
              td.classList.toggle('stamped', tile.stamped);
              td.dataset.row = r;
              td.dataset.col = c;
              tr.appendChild(td);
            });
            modalCard.appendChild(tr);
          });
        }
      }
    });
    
    // Replace native alert with custom modal
    socket.on('win', ({ playerName, winCondition }) => {
      showWinnerModal(playerName, winCondition);
    });
    // Flag selection modal logic
    const flagSelectModal = document.getElementById('flag-select-modal');
    const flagBtn = document.getElementById('flag-button');
    const flagBtnMobile = document.getElementById('flag-button-mobile');
    const flagConfirmBtn = document.getElementById('flag-confirm');
    const flagCancelBtn = document.getElementById('flag-cancel');
    const flagTargetSelect = document.getElementById('flag-target-select');
    const hasFlagModal = !!(flagSelectModal && flagConfirmBtn && flagCancelBtn && flagTargetSelect);
    function openFlagModal() {
      if (!hasFlagModal) return;
      const select = flagTargetSelect;
      select.innerHTML = '<option value="">-- Choose Player --</option>';
      allPlayers.forEach(p => {
        if (p.id !== playerId) {
          const opt = document.createElement('option');
          opt.value = p.id;
          opt.textContent = p.name;
          select.appendChild(opt);
        }
      });
      flagSelectModal.style.display = 'flex';
    }
    if (hasFlagModal) {
      if (flagBtn) flagBtn.addEventListener('click', openFlagModal);
      if (flagBtnMobile) flagBtnMobile.addEventListener('click', openFlagModal);
      flagCancelBtn.addEventListener('click', () => { flagSelectModal.style.display = 'none'; });
      flagConfirmBtn.addEventListener('click', () => {
        const targetId = flagTargetSelect.value;
        if (!targetId) return alert('Select a player to challenge');
        socket.emit('throw_flag', { gameId, flaggerId: playerId, targetPlayerId: targetId });
        flagSelectModal.style.display = 'none';
      });
    }
    
    // Stamp on click (only own card)
    document.querySelectorAll('#card-<%= currentPlayer.id %> td').forEach(td => {
      td.addEventListener('click', (e) => {
        if (isGameOver || td.closest('table').classList.contains('reroll-mode')) return;

        const row = td.dataset.row;
        const col = td.dataset.col;

        // Animate hanko press centered on tile
        (function animateHankoPress(el) {
          const rect = el.getBoundingClientRect();
          const tableEl = el.closest('table');
          tableEl.classList.add('no-cursor');
          const stamp = document.createElement('div');
          stamp.className = 'hanko-press';
          // Size the stamp to 80% of the tile
          stamp.style.width = (rect.width * 0.8) + 'px';
          stamp.style.height = (rect.height * 0.8) + 'px';
          // Position at center of tile, adjusted for page scroll
          const x = rect.left + window.scrollX + (rect.width / 2);
          const y = rect.top + window.scrollY + (rect.height / 2);
          stamp.style.left = x + 'px';
          stamp.style.top = y + 'px';
          document.body.appendChild(stamp);
          stamp.addEventListener('animationend', () => {
            stamp.remove();
            tableEl.classList.remove('no-cursor');
          });
        })(td);

        socket.emit('stamp', { gameId, playerId, row, col });
      });
    });
    // Hanko cursor scaling on card tiles
    (function(){
      const hankoImg = new Image();
      hankoImg.src = '/images/hanko.png';
      hankoImg.onload = () => {
        function applyHankoCursor() {
          // For regular mode, exclude stamped tiles; for VS mode, apply to all tiles
          const selector = gameMode === 'VS'
            ? `#card-<%= currentPlayer.id %> td`
            : `#card-<%= currentPlayer.id %> td:not(.stamped)`;

          document.querySelectorAll(selector).forEach(td => {
            const width = td.offsetWidth;
            const height = td.offsetHeight;
            const scale = 0.8;
            const cw = Math.round(width * scale);
            const ch = Math.round(height * scale);
            const canvas = document.createElement('canvas');
            canvas.width = cw;
            canvas.height = ch;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(hankoImg, 0, 0, cw, ch);
            const xHot = Math.round(cw / 2);
            const yHot = ch;
            const dataURL = canvas.toDataURL('image/png');
            td.style.cursor = `url(${dataURL}) ${xHot} ${yHot}, auto`;
          });
        }
        applyHankoCursor();
        socket.on('update_state', applyHankoCursor);
      };
    })();

    function startNewGame() {
      socket.emit('new_game', { gameId });
      document.body.dataset.timerStatus = 'not_started';
      document.body.dataset.timerStartedAt = '';
      if (window.gameTimer) {
        window.gameTimer.resetToInitial();
      }
      // Close winner modal
      const winnerModal = document.getElementById('winner-modal');
      if (winnerModal) {
        winnerModal.style.display = 'none';
      }
      // Close timer expired modal
      const timerModal = document.getElementById('timer-expired-modal');
      if (timerModal) {
        timerModal.style.display = 'none';
      }
    }

    function copyGameCode() {
      function showSuccess() {
        const confirmEl = document.getElementById('copy-confirm');
        if (confirmEl) {
          confirmEl.style.visibility = 'visible';
          confirmEl.style.color = '#4CAF50';
          confirmEl.textContent = 'Code copied!';
          setTimeout(() => { confirmEl.style.visibility = 'hidden'; }, 3000);
        }
        const toast = document.getElementById('copy-toast-mobile');
        if (toast) {
          toast.textContent = 'Code copied!';
          toast.style.display = 'block';
          setTimeout(() => { toast.style.display = 'none'; }, 2000);
        }
      }
      function showFailWithPrompt(code) {
        // As a last resort, show a prompt the user can long-press/copy from
        try { window.prompt('Copy your game code:', code || ''); } catch (e) {}
        const toast = document.getElementById('copy-toast-mobile');
        if (toast) {
          toast.textContent = 'Shown code to copy';
          toast.style.display = 'block';
          setTimeout(() => { toast.style.display = 'none'; }, 2000);
        }
      }
      function execCopySync(text) {
        try {
          const input = document.getElementById('hidden-copy-input');
          input.value = text || '';
          input.focus();
          input.select();
          input.setSelectionRange(0, input.value.length);
          return document.execCommand('copy');
        } catch (e) { return false; }
      }

      const doCopy = (code) => {
        if (!code) return showFailWithPrompt('');
        // Prefer synchronous execCommand to satisfy Safari gesture requirements
        if (execCopySync(code)) return showSuccess();
        // Try modern API as secondary
        if (navigator.clipboard && window.isSecureContext) {
          navigator.clipboard.writeText(code)
            .then(showSuccess)
            .catch(() => showFailWithPrompt(code));
        } else {
          showFailWithPrompt(code);
        }
      };

      if (window.gameCode) {
        doCopy(window.gameCode);
      } else {
        // Fallback: fetch then attempt copy; if blocked, show prompt
        fetch('/get-code')
          .then(res => res.ok ? res.text() : '')
          .then(code => { window.gameCode = code || null; doCopy(window.gameCode); })
          .catch(() => showFailWithPrompt(window.gameCode));
      }
    }

    function showPlayerCard(targetPlayerId) {
      modalOpenPlayerId = targetPlayerId;
      const player = allPlayers.find(p => p.id === targetPlayerId);
      if (!player) return;

      document.getElementById('modal-player-name').textContent = player.name + "'s Card";
      const modalCard = document.getElementById('modal-card');
      modalCard.innerHTML = '';
      player.card.forEach((row, r) => {
        const tr = document.createElement('tr');
        row.forEach((tile, c) => {
          const td = document.createElement('td');
          const div = document.createElement('div');
          div.className = 'tile-content';
          div.textContent = tile.item;
          td.appendChild(div);
          td.classList.toggle('stamped', tile.stamped);
          td.dataset.row = r;
          td.dataset.col = c;
          tr.appendChild(td);
        });
        modalCard.appendChild(tr);
      });

      const modalReroll = document.getElementById('modal-reroll');
      modalReroll.style.display = isHost ? 'block' : 'none';
      if (isHost) {
        // Reset modal reroll controls for a fresh start
        const typeSelect = document.getElementById('modal-reroll-type');
        typeSelect.value = '';
        const randomBtn = document.getElementById('select-random-modal-button');
        randomBtn.style.display = 'none';
        const instruct = document.getElementById('modal-selection-instruct');
        instruct.style.display = 'none';
        clearModalSelection();
        const modalTable = document.getElementById('modal-card');
        modalTable.classList.remove('reroll-mode');
        if (modalRerollState.clickListener) modalTable.removeEventListener('click', modalRerollState.clickListener);
        modalRerollState = { type: '', arg: '', selectedCells: [], clickListener: null };
        // Bind re-roll for modal
        modalReroll.dataset.targetPlayerId = targetPlayerId;
        document.getElementById('modal-reroll-type').onchange = () => handleModalTypeChange();
        document.getElementById('modal-confirm-reroll').onclick = () => confirmModalReroll();
      }

      document.getElementById('player-modal').style.display = 'block';
    }

    function closeModal() {
      document.getElementById('player-modal').style.display = 'none';
      modalOpenPlayerId = null;
      exitModalReroll();
    }

    // Modal re-roll functions
    let modalRerollState = {
      type: '',
      arg: '',
      selectedCells: [],
      clickListener: null
    };

    function handleModalTypeChange() {
      const select = document.getElementById('modal-reroll-type');
      const type = select.value;
      modalRerollState.type = type;
      clearModalSelection();

      const instruct = document.getElementById('modal-selection-instruct');
      const randomBtn = document.getElementById('select-random-modal-button');
      if (type === 'card') {
        instruct.style.display = 'none';
        randomBtn.style.display = 'none';
        selectModalCard();
      } else if (type === 'random') {
        instruct.style.display = 'none';
        randomBtn.style.display = 'block';
        randomBtn.textContent = 'Select Random Tile';
        randomBtn.onclick = () => selectModalRandomTile();
      } else if (type === 'random_row') {
        instruct.style.display = 'none';
        randomBtn.style.display = 'block';
        randomBtn.textContent = 'Select Random Row';
        randomBtn.onclick = () => selectModalRandomRow();
      } else if (type === 'random_column') {
        instruct.style.display = 'none';
        randomBtn.style.display = 'block';
        randomBtn.textContent = 'Select Random Column';
        randomBtn.onclick = () => selectModalRandomColumn();
      } else if (type === 'random_diagonal') {
        instruct.style.display = 'none';
        randomBtn.style.display = 'block';
        randomBtn.textContent = 'Select Random Diagonal';
        randomBtn.onclick = () => selectModalRandomDiagonal();
      } else if (type) {
        instruct.style.display = 'block';
        randomBtn.style.display = 'none';
      } else {
        instruct.style.display = 'none';
        randomBtn.style.display = 'none';
      }

      const table = document.getElementById('modal-card');
      table.classList.add('reroll-mode');
      if (modalRerollState.clickListener) table.removeEventListener('click', modalRerollState.clickListener);
      const handleClick = (e) => handleModalCardClick(e);
      modalRerollState.clickListener = handleClick;
      table.addEventListener('click', handleClick);
    }

    function handleModalCardClick(e) {
      let td = e.target.closest('td');
      if (!td) return;

      const state = modalRerollState;
      if (!state || !state.type || state.type === 'card') return;

      const row = parseInt(td.dataset.row);
      const col = parseInt(td.dataset.col);
      if (isNaN(row) || isNaN(col)) return;

      clearModalSelection();

      let positions = [];
      let arg = '';

      switch (state.type) {
        case 'tile':
          positions = [[row, col]];
          arg = `${row + 1},${col + 1}`;
          break;
        case 'row':
          positions = Array.from({ length: 5 }, (_, c) => [row, c]);
          arg = `${row + 1}`;
          break;
        case 'column':
          positions = Array.from({ length: 5 }, (_, r) => [r, col]);
          arg = `${col + 1}`;
          break;
        case 'diagonal':
          const isMain = row === col;
          const isAnti = row + col === 4;
          if (!isMain && !isAnti) return;
          if (isMain && isAnti) { // Center
            arg = 'main';
            positions = Array.from({ length: 5 }, (_, i) => [i, i]);
          } else if (isMain) {
            arg = 'main';
            positions = Array.from({ length: 5 }, (_, i) => [i, i]);
          } else if (isAnti) {
            arg = 'anti';
            positions = Array.from({ length: 5 }, (_, i) => [i, 4 - i]);
          }
          break;
      }

      if (positions.length > 0) {
        state.arg = arg;
        state.selectedCells = positions;
        highlightModalSelection(positions);
      }
    }

    function selectModalCard() {
      const positions = Array.from({ length: 25 }, (_, i) => [Math.floor(i / 5), i % 5]);
      modalRerollState.arg = '';
      modalRerollState.selectedCells = positions;
      highlightModalSelection(positions);
    }

    function highlightModalSelection(positions) {
      const table = document.getElementById('modal-card');
      positions.forEach(([r, c]) => {
        table.rows[r].cells[c].classList.add('selected');
      });
    }

    function clearModalSelection() {
      const state = modalRerollState;
      const table = document.getElementById('modal-card');
      state.selectedCells.forEach(([r, c]) => {
        if (table.rows[r] && table.rows[r].cells[c]) {
          table.rows[r].cells[c].classList.remove('selected');
        }
      });
      state.selectedCells = [];
      state.arg = '';
    }

    // Add helper for random tile selection in modal
    function selectModalRandomTile() {
      const state = modalRerollState;
      clearModalSelection();
      const r = Math.floor(Math.random() * 5);
      const c = Math.floor(Math.random() * 5);
      state.arg = `${r+1},${c+1}`;
      state.selectedCells = [[r, c]];
      highlightModalSelection(state.selectedCells);
    }
    function selectModalRandomRow() {
      const state = modalRerollState;
      clearModalSelection();
      const r = Math.floor(Math.random() * 5);
      state.arg = `${r + 1}`;
      state.selectedCells = Array.from({ length: 5 }, (_, c) => [r, c]);
      highlightModalSelection(state.selectedCells);
    }
    function selectModalRandomColumn() {
      const state = modalRerollState;
      clearModalSelection();
      const c = Math.floor(Math.random() * 5);
      state.arg = `${c + 1}`;
      state.selectedCells = Array.from({ length: 5 }, (_, r) => [r, c]);
      highlightModalSelection(state.selectedCells);
    }
    function selectModalRandomDiagonal() {
      const state = modalRerollState;
      clearModalSelection();
      const isMain = Math.random() < 0.5;
      state.arg = isMain ? 'main' : 'anti';
      state.selectedCells = isMain
        ? Array.from({ length: 5 }, (_, i) => [i, i])
        : Array.from({ length: 5 }, (_, i) => [i, 4 - i]);
      highlightModalSelection(state.selectedCells);
    }

    function confirmModalReroll() {
      const state = modalRerollState;
      if (!state || !state.type) {
        alert('Please select a type and an area to re-roll.');
        return;
      }
      const requiresArg = ['tile', 'row', 'column', 'diagonal'];
      if (requiresArg.includes(state.type) && !state.arg && state.type !== 'card') {
        alert('Please select a type and an area to re-roll.');
        return;
      }

      const targetPlayerId = document.getElementById('modal-reroll').dataset.targetPlayerId;
      const emitType = state.type === 'random' ? 'tile' : state.type;
      window.socket.emit('reroll', {
        gameId,
        targetPlayerId,
        type: emitType,
        arg: state.arg
      });

      exitModalReroll();
    }

    function exitModalReroll() {
      const table = document.getElementById('modal-card');
      table.classList.remove('reroll-mode');
      if (modalRerollState.clickListener) table.removeEventListener('click', modalRerollState.clickListener);
      clearModalSelection();
      modalRerollState = { type: '', arg: '', selectedCells: [], clickListener: null };
      document.getElementById('modal-reroll-type').value = '';
    }

    // Drawer functions
    function toggleDrawer(contentType) {
      const drawer = document.getElementById('drawer');
      const drawerContent = drawer.querySelector('.drawer-content');
      drawerContent.innerHTML = '';
      if (drawer.style.bottom === '0px') {
        closeDrawer();
      } else {
        if (contentType === 'leaderboard') {
          const table = document.createElement('table');
          table.id = 'drawer-leaderboard';
          table.innerHTML = `
            <thead>
              <tr>
                <th>Rank</th>
                <th>Player</th>
                <th>Lines</th>
                <th>Stamped Tiles</th>
              </tr>
            </thead>
            <tbody></tbody>
          `;
          drawerContent.appendChild(table);
          updateDrawerLeaderboard(allPlayers, gameMode);
        } // Add more for other types if needed
        drawer.style.bottom = '0px';
      }
    }

    function closeDrawer() {
      document.getElementById('drawer').style.bottom = '-100%';
    }

    function updateDrawerLeaderboard(players, gameMode) {
      const leaderboardBody = document.querySelector('#drawer-leaderboard tbody');
      if (!leaderboardBody) return;
      leaderboardBody.innerHTML = ''; // Clear existing

      // Compute scores (same as main leaderboard)
      const scoredPlayers = players.map(player => {
        let score = 0;
        let stampedCount = 0;

        if (gameMode === 'VS') {
          const squares = player.stampedSquares || [];
          stampedCount = squares.length;

          let stampedGrid = Array(5).fill(null).map(() => Array(5).fill(false));
          squares.forEach(({ row, col }) => {
            stampedGrid[row][col] = true;
          });

          score += stampedGrid.filter(row => row.every(cell => cell)).length;

          for (let col = 0; col < 5; col++) {
            let complete = true;
            for (let row = 0; row < 5; row++) {
              if (!stampedGrid[row][col]) {
                complete = false;
                break;
              }
            }
            if (complete) score++;
          }

          let mainComplete = true;
          let antiComplete = true;
          for (let i = 0; i < 5; i++) {
            if (!stampedGrid[i][i]) mainComplete = false;
            if (!stampedGrid[i][4 - i]) antiComplete = false;
          }
          if (mainComplete) score++;
          if (antiComplete) score++;
        } else {
          const card = player.card;
          card.flat().forEach(tile => {
            if (tile.stamped) stampedCount++;
          });

          score += card.filter(row => row.every(t => t.stamped)).length;

          for (let col = 0; col < 5; col++) {
            let complete = true;
            for (let row = 0; row < 5; row++) {
              if (!card[row][col].stamped) {
                complete = false;
                break;
              }
            }
            if (complete) score++;
          }

          let mainComplete = true;
          let antiComplete = true;
          for (let i = 0; i < 5; i++) {
            if (!card[i][i].stamped) mainComplete = false;
            if (!card[i][4 - i].stamped) antiComplete = false;
          }
          if (mainComplete) score++;
          if (antiComplete) score++;
        }

        return { id: player.id, name: player.name, score, stampedCount, color: player.color };
      });

      scoredPlayers.sort((a, b) => b.score - a.score || b.stampedCount - a.stampedCount);

      scoredPlayers.forEach((p, index) => {
        const tr = document.createElement('tr');
        const colorBadge = gameMode === 'VS' && p.color ? `<span class="color-badge ${p.color}"></span>` : '';
        const nameTd = `<td>${colorBadge}${p.id === playerId ? p.name : `<span style="cursor: pointer; text-decoration: underline;" onclick="showPlayerCard('${p.id}')">${p.name}</span>`}</td>`;
        tr.innerHTML = `
          <td>${index + 1}</td>
          ${nameTd}
          <td>${p.score}</td>
          <td>${p.stampedCount}</td>
        `;
        leaderboardBody.appendChild(tr);
      });
    }
    // Swipe to close drawer on mobile via downward swipe gesture
    (function() {
      const drawerEl = document.getElementById('drawer');
      let drawerStartY = null;
      drawerEl.addEventListener('touchstart', function(e) {
        // Only start if drawer is open
        if (drawerEl.style.bottom === '0px') {
          drawerStartY = e.touches[0].clientY;
        }
      });
      drawerEl.addEventListener('touchmove', function(e) {
        if (drawerStartY === null) return;
        const touchY = e.touches[0].clientY;
        const delta = touchY - drawerStartY;
        if (delta > 50) {
          closeDrawer();
          drawerStartY = null;
        }
      });
    })();
  // Show/Hide functions for winner modal
  function showWinnerModal(playerName, winCondition) {
    const modal = document.getElementById('winner-modal');
    document.getElementById('winner-modal-name').textContent = `${playerName} Wins!`;

    if (winCondition) {
      document.getElementById('winner-modal-condition').textContent = `with ${winCondition}`;
    } else {
      document.getElementById('winner-modal-condition').textContent = '';
    }

    modal.style.display = 'flex';
  }
  function closeWinnerModal() {
    document.getElementById('winner-modal').style.display = 'none';
  }

  // Chat functionality
  (function() {
    const chatPanel = document.getElementById('chat-panel');
    const chatToggleDesktop = document.getElementById('chat-toggle-desktop');
    const chatToggleMobile = document.getElementById('chat-toggle-mobile');
    const chatCloseDesktop = document.getElementById('chat-close-desktop');
    const chatSend = document.getElementById('chat-send');
    const chatInput = document.getElementById('chat-input');
    const chatMessages = document.getElementById('chat-messages');
    const chatNotification = document.getElementById('chat-notification');
    const chatNotificationMobile = document.getElementById('chat-notification-mobile');
    const { players: chatPlayers, messages: chatHistory } = JSON.parse(document.getElementById('chat-data').textContent);
    const chatColors = {};
    const availableColors = ['#A3E635','#60A5FA','#F472B6','#FBBF24','#34D399','#F87171','#C084FC','#FCD34D','#38BDF8','#A78BFA'];
    chatPlayers.forEach((p,i) => { chatColors[p.id] = availableColors[i % availableColors.length]; });
    const chatNames = {};
    chatPlayers.forEach(p => { chatNames[p.id] = p.name; });

    function addChatMessage(msg) {
      const bubble = document.createElement('div');
      bubble.classList.add('chat-bubble', msg.playerId === playerId ? 'self' : 'other');
      bubble.style.backgroundColor = chatColors[msg.playerId] || '#ddd';
      // name header
      const header = document.createElement('div');
      header.classList.add('bubble-header');
      header.textContent = msg.playerId === playerId ? 'You' : chatNames[msg.playerId];
      bubble.appendChild(header);
      // message content
      const content = document.createElement('div');
      content.classList.add('bubble-content');
      content.textContent = msg.content;
      bubble.appendChild(content);
      // timestamp
      const time = document.createElement('div');
      time.classList.add('bubble-time');
      time.textContent = new Date(msg.createdAt).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
      bubble.appendChild(time);
      chatMessages.appendChild(bubble);
      chatMessages.scrollTop = chatMessages.scrollHeight;
    }

    chatHistory.forEach(addChatMessage);

    chatToggleDesktop.addEventListener('click', () => {
      chatPanel.classList.toggle('open');
      if (chatPanel.classList.contains('open')) {
        chatNotification.style.display = 'none';
        if (chatNotificationMobile) chatNotificationMobile.style.display = 'none';
      }
    });
    chatToggleMobile.addEventListener('click', () => {
      chatPanel.classList.toggle('open');
      if (chatPanel.classList.contains('open')) {
        chatNotification.style.display = 'none';
        if (chatNotificationMobile) chatNotificationMobile.style.display = 'none';
      }
    });
    chatCloseDesktop.addEventListener('click', () => chatPanel.classList.remove('open'));

    chatSend.addEventListener('click', () => {
      const content = chatInput.value.trim();
      if (!content) return;
      socket.emit('chat_message', { gameId, playerId, content });
      chatInput.value = '';
    });
    chatInput.addEventListener('keydown', e => {
      if (e.key === 'Enter') { e.preventDefault(); chatSend.click(); }
    });

    socket.on('new_message', ({ message }) => {
      addChatMessage(message);
      if (!chatPanel.classList.contains('open')) {
        chatNotification.style.display = 'block';
        if (chatNotificationMobile) chatNotificationMobile.style.display = 'block';
      }
    });
  })();
  </script>
  <script src="/js/vote.js"></script>
  <script>
    function toggleStreamerMode() {
      document.body.classList.toggle('streamer-mode');
      const btn = document.getElementById('streamer-toggle-btn');
      if (document.body.classList.contains('streamer-mode')) {
        btn.textContent = 'Streamer Mode: On';
      } else {
        btn.textContent = 'Streamer Mode: Off';
      }
    }
    /** Toggle streamer mode for non-host players */
    function toggleStreamerModeNonHost() {
      document.body.classList.toggle('streamer-mode');
      const btnNH = document.getElementById('streamer-toggle-btn-nonhost');
      if (document.body.classList.contains('streamer-mode')) {
        btnNH.textContent = 'Streamer Mode: On';
      } else {
        btnNH.textContent = 'Streamer Mode: Off';
      }
    }
  </script>
</body>
</html>
