<!DOCTYPE html>
<html lang="<%= locale || 'en' %>">
<head>
  <% 
    const isVsMode = game.mode === 'VS';
    const modeToken = isVsMode
      ? (locale === 'ja' ? '„É≠„ÉÉ„ÇØ„Ç¢„Ç¶„Éà„Éì„É≥„Ç¥' : 'Lockout Bingo')
      : (locale === 'ja' ? '„Ç≤„Éº„Éû„Éº„Éì„É≥„Ç¥' : 'Gamer Bingo');
    const pageTitle = t('seo.game.title', { mode: modeToken });
    const pageDescription = t('seo.game.description', { mode: modeToken });
    const canonicalUrl = typeof buildCanonical === 'function' ? buildCanonical('/game') : (siteUrl ? `${siteUrl}/game` : '/game');
    const shareImage = typeof buildCanonical === 'function' ? buildCanonical('/tokyo-cam-bingo.png') : '/tokyo-cam-bingo.png';
  %>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title><%= pageTitle %></title>
  <meta name="description" content="<%= pageDescription %>">
  <meta name="robots" content="noindex, nofollow">
  <link rel="canonical" href="<%= canonicalUrl %>">
  <meta property="og:type" content="website">
  <meta property="og:url" content="<%= canonicalUrl %>">
  <meta property="og:title" content="<%= pageTitle %>">
  <meta property="og:description" content="<%= pageDescription %>">
  <meta property="og:image" content="<%= shareImage %>">
  <meta property="og:site_name" content="<%= t('common.appName') %>">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="<%= pageTitle %>">
  <meta name="twitter:description" content="<%= pageDescription %>">
  <meta name="twitter:image" content="<%= shareImage %>">
  <meta name="google-site-verification" content="EDU39xuTQRdazoV6JCNadlQGNms3bWyW-0-BGy1eFOY">
  <meta name="theme-color" content="#FF69B4">
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="manifest" href="/site.webmanifest">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="TCB">
  <meta name="csrf-token" content="<%= csrfToken %>">

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@500&family=Roboto&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="/css/styles.css?v=<%= assetVersion %>">
  <script src="/js/pwa-install.js?v=<%= assetVersion %>" defer></script>
  <script src="/js/theme-toggle.js?v=<%= assetVersion %>" defer></script>
  <script src="/socket.io/socket.io.js"></script>
  <script src="/js/timer.js?v=<%= assetVersion %>"></script>
  <script src="/js/game.js?v=<%= assetVersion %>"></script>
</head>
<body class="game-page <%= theme === 'dark' ? 'theme-dark' : 'theme-light' %>" data-theme="<%= theme %>" data-game-id="<%= game.id %>" data-player-id="<%= currentPlayer.id %>" data-player-name="<%= currentPlayer.name %>" data-is-host="<%= currentPlayer.isHost %>" data-game-status="<%= game.status %>" data-game-mode="<%= game.mode %>" data-board-size="<%= game.boardSize %>" data-flags-enabled="<%= game.flagsEnabled %>" data-rerolls-enabled="<%= game.rerollsEnabled %>" data-player-color="<%= currentPlayer.color || '' %>" data-asset-version="<%= assetVersion %>" data-sw-enabled="<%= enableServiceWorker %>" data-timer-enabled="<%= game.timerEnabled %>" data-timer-duration="<%= game.timerDuration || 0 %>" data-timer-status="<%= game.timerStatus || 'not_started' %>" data-timer-started-at="<%= game.timerStartedAt ? game.timerStartedAt.toISOString() : '' %>" data-locale="<%= locale %>">
<aside class="sidebar">
  <div class="sidebar-header">
    <div class="sidebar-controls sidebar-controls--left">
      <div class="sidebar-icon-button">
        <button
          type="button"
          class="sidebar-icon-button__inner"
          onclick="copyGameCode()"
          aria-label="<%= t('actions.copyCode') %>"
        >
          <svg class="sidebar-icon-svg" viewBox="0 0 24 24" role="presentation" focusable="false">
            <rect x="6" y="5" width="12" height="14" rx="2" />
            <path d="M9 5V3h6v2" />
            <path d="M9 8h6" />
          </svg>
        </button>
        <span class="sidebar-tooltip"><%= t('actions.copyCode') %></span>
        <span id="copy-confirm" class="sidebar-copy-confirm"><%= t('notifications.codeCopied') %></span>
      </div>
    </div>
    <div class="sidebar-controls sidebar-controls--right">
      <div class="sidebar-icon-button">
        <button
          type="button"
          id="chat-toggle-desktop"
          class="sidebar-icon-button__inner"
          aria-label="<%= t('game.chatToggle') %>"
        >
          <svg class="sidebar-icon-svg" viewBox="0 0 24 24" role="presentation" focusable="false">
            <path d="M4 5h16v11H9l-5 5V5z" />
          </svg>
          <span id="chat-notification" class="notification-badge"></span>
        </button>
        <span class="sidebar-tooltip"><%= t('game.chatTitle') %></span>
      </div>
      <% if (game.flagsEnabled) { %>
        <div class="sidebar-icon-button">
          <button
            type="button"
            id="flag-button"
            class="sidebar-icon-button__inner"
            aria-label="<%= t('game.flagButton') %>"
          >
            <svg class="sidebar-icon-svg" viewBox="0 0 24 24" role="presentation" focusable="false">
              <path d="M6 20V5" />
              <path d="M6 5h12l-3.5 3.5L18 12H6" />
            </svg>
          </button>
          <span class="sidebar-tooltip"><%= t('game.flagButton') %></span>
        </div>
      <% } %>
    </div>
  </div>

  <!-- Timer Display (Desktop) -->
  <% if (game.timerEnabled) { %>
    <div class="timer-display-section">
      <div class="timer-display-info">
        <div id="game-timer" class="game-timer">
          <div class="timer-value" id="timer-value">--:--</div>
        </div>
      </div>
      <% if (currentPlayer.isHost) { %>
        <div class="timer-controls timer-controls-desktop">
          <button id="start-timer-btn" class="timer-control-btn timer-start-btn" onclick="startTimer()" style="display: block;"><%= t('game.timerStart') %></button>
          <button id="pause-timer-btn" class="timer-control-btn timer-pause-btn" onclick="pauseTimer()" style="display: none;"><%= t('game.timerPause') %></button>
          <button id="resume-timer-btn" class="timer-control-btn timer-resume-btn" onclick="resumeTimer()" style="display: none;"><%= t('game.timerResume') %></button>
          <button id="reset-timer-btn" class="timer-control-btn timer-reset-btn" onclick="resetTimer()" style="display: none;"><%= t('game.timerReset') %></button>
        </div>
      <% } %>
    </div>
  <% } %>

  <div class="leaderboard-section">
    <div class="leaderboard-card">
        <table id="leaderboard">
          <thead>
            <tr>
              <th><%= t('game.leaderboardRank') %></th>
              <th><%= t('game.leaderboardPlayer') %></th>
              <th><%= t('game.leaderboardLines') %></th>
              <th><%= t('game.leaderboardTiles') %></th>
            </tr>
          </thead>
        <tbody></tbody>
      </table>
    </div>
  </div>
</aside>

<%
  const streamGuide = t('game.streamInstructions') || {};
  const streamSteps = Array.isArray(streamGuide.steps) ? streamGuide.steps : [];
  const shareHelperRaw = t('game.deviceLink.shareHelper');
  const shareHelperText = shareHelperRaw && shareHelperRaw !== 'game.deviceLink.shareHelper'
    ? shareHelperRaw
    : 'Copy this URL somewhere safe so you can re-open the link without scanning again, incase you close it or something unexpected happens.';
%>

<!-- Hamburger Menu (Lower Left) -->
<div class="hamburger-menu-container">
  <button class="hamburger-toggle" onclick="toggleHamburgerMenu()" aria-label="Toggle menu">
    <span class="hamburger-icon">‚ò∞</span>
  </button>
  <div class="hamburger-menu" id="hamburger-menu" style="display: none;">
    <div class="hamburger-menu-content">
      <div class="hamburger-preferences">
        <%- include('partials/theme-toggle', { themeToggleVariant: 'stacked' }) %>
      </div>
      <button id="streamer-toggle-btn" onclick="toggleStreamerMode(); closeHamburgerOnMobile();"><span data-streamer-state="off"><%= t('game.streamerModeOff') %></span></button>
      <button id="minimal-toggle-btn" onclick="toggleMinimalMode(); closeHamburgerOnMobile();"><span data-minimal-state="off"><%= t('game.minimalModeOff') %></span></button>
      <button id="stream-instructions-btn" onclick="openStreamInstructions(); closeHamburgerOnMobile();"><%= streamGuide.buttonLabel || 'OBS Setup Guide' %></button>
      <button id="popout-btn" onclick="popoutCard(); closeHamburgerOnMobile();"><%= t('game.popoutCard') %></button>
      <button id="device-link-btn" onclick="openDeviceLinkModal(); closeHamburgerOnMobile();"><%= t('game.deviceLink.openButton') %></button>
      <% if (currentPlayer.isHost && game.rerollsEnabled) { %>
        <hr class="hamburger-divider">
        <button onclick="enterRerollMode('<%= currentPlayer.id %>'); closeHamburgerOnMobile();"><%= t('actions.enterRerollMode') %></button>
        <div id="reroll-mode-<%= currentPlayer.id %>" style="display:none;">
          <select id="reroll-type-<%= currentPlayer.id %>" onchange="handleTypeChange('<%= currentPlayer.id %>')">
            <option value=""><%= t('game.reroll.selectType') %></option>
            <option value="tile"><%= t('game.reroll.options.tile') %></option>
            <option value="row"><%= t('game.reroll.options.row') %></option>
            <option value="column"><%= t('game.reroll.options.column') %></option>
            <option value="diagonal"><%= t('game.reroll.options.diagonal') %></option>
            <option value="card"><%= t('game.reroll.options.card') %></option>
            <option value="random"><%= t('game.reroll.options.randomTile') %></option>
            <option value="random_row"><%= t('game.reroll.options.randomRow') %></option>
            <option value="random_column"><%= t('game.reroll.options.randomColumn') %></option>
            <option value="random_diagonal"><%= t('game.reroll.options.randomDiagonal') %></option>
          </select>
          <p id="selection-instruct-<%= currentPlayer.id %>"><%= t('game.reroll.instruction') %></p>
          <button id="select-random-button-<%= currentPlayer.id %>" style="display:none;" onclick="selectRandomTile('<%= currentPlayer.id %>')"><%= t('game.reroll.randomButton') %></button>
          <button onclick="confirmReroll('<%= currentPlayer.id %>')"><%= t('game.reroll.confirm') %></button>
          <button onclick="exitRerollMode('<%= currentPlayer.id %>')"><%= t('actions.cancel') %></button>
        </div>
      <% } %>
    </div>
  </div>
</div>

<div id="device-link-modal" class="modal-overlay" style="display:none;">
  <div class="modal-card modal-card--device-link" role="dialog" aria-modal="true" aria-labelledby="device-link-title">
    <div class="device-link-scroll">
      <div class="modal-header">
        <span aria-hidden="true">üì±</span>
        <h3 id="device-link-title" class="modal-title"><%= t('game.deviceLink.modalTitle') %></h3>
      </div>
      <p class="modal-subtitle modal-subtitle--muted"><%= t('game.deviceLink.modalDescription') %></p>
      <p class="device-link-note"><%= t('game.deviceLink.note') %></p>
      <div class="device-link-display" aria-live="polite">
        <div class="device-link-field">
          <span class="device-link-label"><%= t('game.deviceLink.codeLabel') %></span>
          <div id="device-link-code" class="device-link-value">------</div>
        </div>
        <div class="device-link-field">
          <span class="device-link-label"><%= t('game.deviceLink.pinLabel') %></span>
          <div id="device-link-pin" class="device-link-value device-link-pin">----</div>
        </div>
      </div>
      <div class="device-link-qr-wrapper">
        <img id="device-link-qr" alt="<%= t('game.deviceLink.qrAlt') %>">
        <div id="device-link-placeholder" class="device-link-placeholder"><%= t('game.deviceLink.placeholder') %></div>
      </div>
    <div class="device-link-share">
      <span class="device-link-share-label"><%= t('game.deviceLink.shareLabel') %></span>
      <div class="device-link-share-row">
        <input id="device-link-url" type="text" readonly value="">
        <button type="button" onclick="copyDeviceLinkUrl()"><%= t('game.deviceLink.copyLink') %></button>
      </div>
      <p class="device-link-note"><%= shareHelperText %></p>
    </div>
    <p class="device-link-note"><%= t('game.deviceLink.manualReminder') %></p>
      <p id="device-link-expiry" class="device-link-expiry"></p>
      <p id="device-link-status" class="device-link-status"></p>
      <p id="device-link-error" class="modal-error"></p>
    </div>
    <div class="modal-actions device-link-actions">
      <button type="button" id="device-link-refresh" onclick="requestDeviceLink()"><%= t('game.deviceLink.generate') %></button>
      <button type="button" class="btn btn-secondary" onclick="closeDeviceLinkModal()"><%= t('actions.close') %></button>
    </div>
    <div id="device-link-warning" class="device-link-warning" role="alertdialog" aria-modal="true">
      <div class="device-link-warning-card">
        <h3><%= t('game.deviceLink.warningTitle') %></h3>
        <p><%= t('game.deviceLink.warningBody') %></p>
        <button type="button" class="device-link-warning-button" onclick="acknowledgeDeviceLinkWarning()"><%= t('game.deviceLink.warningAction') %></button>
      </div>
    </div>
</div>
</div>

<button
  id="minimal-exit-button"
  class="minimal-exit-btn"
  type="button"
  onclick="exitMinimalMode()"
  aria-label="<%= t('game.minimalModeExit') %>">
  <span><%= t('game.minimalModeExit') %></span>
</button>

  <div class="container">
    <div class="game-header">
    <%
      const winConditions = Array.isArray(game.rules.winConditions) ? game.rules.winConditions : [];
      const formattedWinConditions = winConditions.map((condition) => {
        const key = `game.winConditions.list.${condition}`;
        const translated = t(key);
        return translated === key ? condition : translated;
      });
    %>
    <h1 style="font-size: 0.9rem; margin-top: 1rem;"><%= t('game.winConditions.heading') %> <%= formattedWinConditions.length ? formattedWinConditions.join(', ') : t('game.winConditions.none') %></h1>

    <!-- Timer Display (Mobile) -->
  <% if (game.timerEnabled) { %>
    <div class="timer-display-mobile mobile-only">
      <div class="timer-display-info">
        <div id="game-timer-mobile" class="game-timer game-timer-mobile">
          <div class="timer-value" id="timer-value-mobile">--:--</div>
        </div>
      </div>
        <% if (currentPlayer.isHost) { %>
          <div class="timer-controls timer-controls-mobile">
          <button id="start-timer-btn-mobile" class="timer-control-btn timer-start-btn" onclick="startTimer()"><%= t('game.timerStart') %></button>
          <button id="pause-timer-btn-mobile" class="timer-control-btn timer-pause-btn" onclick="pauseTimer()" style="display: none;"><%= t('game.timerPause') %></button>
            <button id="resume-timer-btn-mobile" class="timer-control-btn timer-resume-btn" onclick="resumeTimer()" style="display: none;"><%= t('game.timerResume') %></button>
            <button id="reset-timer-btn-mobile" class="timer-control-btn timer-reset-btn" onclick="resetTimer()" style="display: none;"><%= t('game.timerReset') %></button>
          </div>
        <% } %>
      </div>
    <% } %>

    <!-- header-controls removed in favor of sidebar -->
  </div>

    <div class="game-layout">
      <div class="card-section">
        <div class="card-cover-overlay <%= currentPlayer.cardRevealed ? 'hidden' : '' %>" id="card-cover" onclick="revealCard()">
          <div class="cover-icon">üé¥</div>
          <div class="cover-text"><%= t('game.cardCover.title') %></div>
          <div class="cover-subtext"><%= t('game.cardCover.subtitle') %></div>
        </div>
        <table id="card-<%= currentPlayer.id %>" class="bingo-card <%= game.mode === 'VS' ? 'vs-card' : 'own-card' %>">
          <% currentPlayer.card.forEach((row, r) => { %>
            <tr>
              <% row.forEach((tile, c) => { %>
                <td class="<%= tile.stamped ? 'stamped' : '' %>" data-row="<%= r %>" data-col="<%= c %>">
                  <div class="tile-content"><%= translateItem(tile.item) %></div>
                </td>
              <% }) %>
            </tr>
          <% }) %>
        </table>

        <!-- Original host reroll controls removed here -->
      </div>
      
      <!-- original leaderboard-section removed in favor of sidebar -->
    </div>
  </div>

  <!-- Bottom App Bar for Mobile -->
  <div class="bottom-app-bar mobile-only">
    <button
      type="button"
      class="bottom-app-bar__button"
      onclick="toggleDrawer('leaderboard')"
      aria-label="<%= t('game.leaderboard') %>"
      title="<%= t('game.leaderboard') %>"
    >
      <span class="sr-only"><%= t('game.leaderboard') %></span>
      <span class="bottom-app-bar__icon" aria-hidden="true">
        <svg width="20" height="20" viewBox="0 0 24 24" role="presentation" focusable="false">
          <path d="M4 20h16" />
          <path d="M7 20v-7" />
          <path d="M12 20V8" />
          <path d="M17 20v-9" />
        </svg>
      </span>
    </button>
    <button
      type="button"
      id="chat-toggle-mobile"
      class="bottom-app-bar__button"
      aria-label="<%= t('game.chatToggle') %>"
      title="<%= t('game.chatToggle') %>"
    >
      <span class="sr-only"><%= t('game.chatToggle') %></span>
      <span class="bottom-app-bar__icon" aria-hidden="true">
        <svg width="20" height="20" viewBox="0 0 24 24" role="presentation" focusable="false">
          <path d="M5 5h14v10H9l-4 4V5z" />
        </svg>
        <span id="chat-notification-mobile" class="notification-badge"></span>
      </span>
    </button>
    <% if (game.flagsEnabled) { %>
      <button
        type="button"
        id="flag-button-mobile"
        class="bottom-app-bar__button"
        aria-label="<%= t('game.flagButton') %>"
        title="<%= t('game.flagButton') %>"
      >
        <span class="sr-only"><%= t('game.flagButton') %></span>
        <span class="bottom-app-bar__icon" aria-hidden="true">
          <svg width="20" height="20" viewBox="0 0 24 24" role="presentation" focusable="false">
            <path d="M7 20V6" />
            <path d="M7 6h9l-2.5 2.5L16 11H7" />
          </svg>
        </span>
      </button>
    <% } %>
    <% if (currentPlayer.isHost) { %>
      <button
        type="button"
        id="copy-code-mobile"
        class="bottom-app-bar__button"
        onclick="copyGameCode()"
        aria-label="<%= t('actions.copyCode') %>"
        title="<%= t('actions.copyCode') %>"
      >
        <span class="sr-only"><%= t('actions.copyCode') %></span>
        <span class="bottom-app-bar__icon" aria-hidden="true">
          <svg width="20" height="20" viewBox="0 0 24 24" role="presentation" focusable="false">
            <rect x="8" y="7" width="8" height="12" rx="1.5" />
            <path d="M9 4h6" />
            <path d="M9 6h6" />
          </svg>
        </span>
      </button>
    <% } %>
  </div>
  <!-- Centered mobile toast for copy code -->
  <div id="copy-toast-mobile" class="mobile-only" style="display:none;"><%= t('notifications.codeCopied') %></div>
  <!-- Hidden input used for Safari execCommand copy fallback -->
  <input id="hidden-copy-input" type="text" readonly style="position:fixed; top:-1000px; left:-1000px; opacity:0; pointer-events:none;" />

  <!-- Slide-up Drawer -->
  <div id="drawer" class="drawer">
    <div class="drawer-content">
      <!-- Content populated dynamically -->
    </div>
    <button class="close-drawer" onclick="closeDrawer()"><%= t('actions.close') %></button>
  </div>

  <!-- Winner Modal -->
  <div id="winner-modal" class="modal-overlay" style="display:none;">
    <div class="modal-card modal-card--status">
      <h2 id="winner-modal-name" class="modal-title modal-title--success modal-title--xl"><%= t('game.winnerHeading') %></h2>
      <p id="winner-modal-condition" class="modal-subtitle modal-subtitle--strong"><%= t('game.winnerConditionLabel') %></p>
      <div id="winner-modal-buttons" class="modal-actions modal-actions--wrap">
        <% if (currentPlayer.isHost) { %>
          <button class="btn btn-accent btn-lg" onclick="startNewGame()"><%= t('game.winnerNewGame') %></button>
        <% } %>
        <button class="btn btn-heading btn-lg" onclick="location.href = '/'">
          <%= t('game.exitToHome') %>
        </button>
      </div>
    </div>
  </div>

  <!-- Timer Expired Modal -->
  <div id="timer-expired-modal" class="modal-overlay" style="display:none;">
    <div class="modal-card modal-card--status">
      <div class="modal-icon" aria-hidden="true">‚è∞</div>
      <h2 id="timer-expired-title" class="modal-title modal-title--warning modal-title--xl"><%= t('game.timerExpired.title') %></h2>
      <p id="timer-expired-message" class="modal-subtitle modal-subtitle--muted"><%= t('game.timerExpired.message') %></p>
      <p id="timer-expired-winner" class="modal-subtitle modal-subtitle--success" style="display: none;">
        <%= t('game.timerExpired.winnerPrefix') %> <span id="timer-expired-winner-name"></span>
      </p>
      <div class="modal-actions modal-actions--wrap">
        <% if (currentPlayer.isHost) { %>
          <button class="btn btn-accent btn-lg" onclick="startNewGame(); closeTimerExpiredModal();"><%= t('game.winnerNewGame') %></button>
        <% } %>
        <button class="btn btn-heading btn-lg" onclick="location.href = '/'">
          <%= t('game.exitToHome') %>
        </button>
      </div>
    </div>
  </div>
  <!-- Modal for opponent cards -->
  <div id="player-modal" class="modal-overlay modal-overlay--scroll" style="display: none;">
    <div class="modal-card modal-card--player">
      <button type="button" class="modal-close-button" onclick="closeModal()" aria-label="<%= t('actions.close') %>">&times;</button>
      <h2 id="modal-player-name"></h2>
      <table id="modal-card" class="bingo-card own-card"></table>
      <div id="modal-reroll" style="display: none;">
        <h3><%= t('game.reroll.modalTitle') %></h3>
        <select id="modal-reroll-type">
          <option value=""><%= t('game.reroll.selectType') %></option>
          <option value="tile"><%= t('game.reroll.options.tile') %></option>
          <option value="row"><%= t('game.reroll.options.row') %></option>
          <option value="column"><%= t('game.reroll.options.column') %></option>
          <option value="diagonal"><%= t('game.reroll.options.diagonal') %></option>
          <option value="card"><%= t('game.reroll.options.card') %></option>
          <option value="random"><%= t('game.reroll.options.randomTile') %></option>
          <option value="random_row"><%= t('game.reroll.options.randomRow') %></option>
          <option value="random_column"><%= t('game.reroll.options.randomColumn') %></option>
          <option value="random_diagonal"><%= t('game.reroll.options.randomDiagonal') %></option>
        </select>
        <p id="modal-selection-instruct"><%= t('game.reroll.instruction') %></p>
        <button id="select-random-modal-button" style="display:none;" onclick="selectModalRandomTile()"><%= t('game.reroll.randomButton') %></button>
        <button id="modal-confirm-reroll"><%= t('game.reroll.confirm') %></button>
        <button onclick="exitModalReroll()"><%= t('actions.cancel') %></button>
      </div>
    </div>
  </div>
  
  <!-- Vote Modal -->
  <div id="vote-modal" class="modal-overlay" style="display:none;">
    <div class="modal-card">
      <div class="modal-header">
        <span style="font-size:1.25rem;">üö©</span>
        <h3 id="vote-modal-text" class="modal-title"><%= t('game.voteModal.title') %></h3>
      </div>
      <p id="vote-modal-message" class="modal-subtitle"></p>
      <div id="vote-buttons" class="modal-actions">
        <button id="vote-yes" class="btn btn-primary"><%= t('game.voteModal.yes') %></button>
        <button id="vote-no" class="btn btn-danger"><%= t('game.voteModal.no') %></button>
      </div>
      <div class="badges">
        <span class="badge" id="vote-count"><%= t('game.voteModal.count', { yes: 0, no: 0 }) %></span>
      </div>
      <div id="vote-result" class="modal-footer" style="display:none;">
        <p id="vote-outcome" class="modal-subtitle" style="margin-bottom:0.5rem;"></p>
        <ul id="vote-details" class="vote-list"></ul>
        <div class="modal-actions">
          <button id="vote-close" class="btn btn-secondary"><%= t('actions.close') %></button>
        </div>
      </div>
    </div>
  </div>

  <!-- Flag Select Modal -->
  <div id="flag-select-modal" class="modal-overlay" style="display:none;">
    <div class="modal-card">
      <div class="modal-header">
        <span style="font-size:1.25rem;">üö©</span>
        <h3 class="modal-title"><%= t('game.flagModal.title') %></h3>
      </div>
      <p class="modal-subtitle"><%= t('game.flagModal.subtitle') %></p>
      <select id="flag-target-select">
        <option value=""><%= t('game.flagModal.placeholder') %></option>
      </select>
      <div class="modal-actions">
        <button id="flag-confirm" class="btn btn-primary"><%= t('game.flagModal.confirm') %></button>
        <button id="flag-cancel" class="btn btn-secondary"><%= t('actions.cancel') %></button>
      </div>
    </div>
  </div>

  <!-- Card Hidden Modal -->
  <div id="card-hidden-modal" class="modal-overlay" style="display:none;">
    <div class="modal-card modal-card--status">
      <div class="modal-icon" aria-hidden="true">üôà</div>
      <h2 class="modal-title modal-title--warning"><%= t('game.cardNotRevealedTitle') %></h2>
      <p class="modal-subtitle modal-subtitle--muted"><%= t('game.cardNotRevealed') %></p>
      <div class="modal-actions">
        <button type="button" class="btn btn-heading" onclick="closeCardHiddenModal()"><%= t('actions.close') %></button>
      </div>
    </div>
  </div>

  <div id="stream-instructions-modal" class="modal-overlay" style="display:none;">
    <div class="modal-card modal-card--instructions" role="dialog" aria-modal="true" aria-labelledby="stream-instructions-title">
      <div class="modal-header">
        <span aria-hidden="true">üé•</span>
        <h3 id="stream-instructions-title" class="modal-title" tabindex="-1"><%= streamGuide.title || 'Stream the Popout in OBS' %></h3>
      </div>
      <% if (streamGuide.intro) { %>
        <p class="modal-subtitle modal-subtitle--muted"><%= streamGuide.intro %></p>
      <% } %>
      <% if (streamSteps.length) { %>
        <ol class="modal-ordered-list">
          <% streamSteps.forEach((step) => { %>
            <li><%= step %></li>
          <% }); %>
        </ol>
      <% } %>
      <div class="modal-actions">
        <button type="button" class="btn btn-secondary" onclick="closeStreamInstructions()"><%= t('actions.close') %></button>
      </div>
    </div>
  </div>
  
  <div id="chat-panel" class="chat-panel">
    <div class="chat-header">
      <h2><%= t('game.chatTitle') %></h2>
      <button id="chat-close-desktop" aria-label="<%= t('actions.close') %>">&times;</button>
    </div>
    <div id="chat-messages" class="chat-messages"></div>
    <div class="chat-input">
      <input id="chat-input" type="text" maxlength="300" placeholder="<%= t('game.chatPlaceholder') %>" />
      <button id="chat-send"><%= t('game.chatSend') %></button>
    </div>
  </div>
  
  <%- include('partials/i18n-script', { namespaces: ['game', 'alerts', 'notifications', 'items'] }) %>
  <script id="chat-data" type="application/json"><%- JSON.stringify({ players, messages }) %></script>
  <script>
    // Clear any cached data to prevent stale game states
    (function() {
      try {
        // Don't clear storage on game page as it might affect sessions
        // Just ensure we're loading fresh data from server
      } catch (e) {
        console.warn('Storage check failed:', e);
      }
    })();

    const socket = io();
    const translateText = (key, vars) => (typeof window.t === 'function' ? window.t(key, vars) : key);
    const translateItemText = (value) => {
      const dict = window.APP_I18N && window.APP_I18N.items;
      return (dict && dict[value]) || value;
    };
    window.socket = socket;
    const gameId = document.body.dataset.gameId;
    const playerId = document.body.dataset.playerId;
    const playerName = document.body.dataset.playerName;
    const isHost = document.body.dataset.isHost === 'true';
    const csrfTokenValue = (document.querySelector('meta[name="csrf-token"]') || { getAttribute: () => '' }).getAttribute('content') || '';
    const boardSize = Number(document.body.dataset.boardSize) || 5;
    const totalTiles = boardSize * boardSize;
    const lastBoardIndex = boardSize - 1;
    const deviceLinkState = {
      modal: null,
      loading: false,
      current: null,
      expiresAt: null,
      expiryTimer: null,
      warningAcknowledged: false
    };
    const deviceLinkPlaceholderCode = '------';
    const deviceLinkPlaceholderPin = '----';

    // Initialize game timer if enabled
    let gameTimer = null;
    if (window.GameTimer) {
      gameTimer = new GameTimer(socket);
      window.gameTimer = gameTimer;
    }
    const gameMode = document.body.dataset.gameMode;
    const flagsEnabled = document.body.dataset.flagsEnabled === 'true';
    const rerollsEnabled = document.body.dataset.rerollsEnabled === 'true';
    const playerColor = document.body.dataset.playerColor;
    let isGameOver = document.body.dataset.gameStatus === 'ended';
    const bootstrapDataEl = document.getElementById('chat-data');
    let bootstrapData = { players: [], messages: [] };
    if (bootstrapDataEl) {
      try {
        bootstrapData = JSON.parse(bootstrapDataEl.textContent || '{}');
      } catch (error) {
        console.error('Failed to parse bootstrap game data', error);
      }
    }
    window.bootstrapGameData = bootstrapData;
    let allPlayers = Array.isArray(bootstrapData.players) ? bootstrapData.players.slice() : []; // Global to store all players
    let modalOpenPlayerId = null; // Track open modal player
    // Preload game code for host to allow synchronous copy on Safari
    window.gameCode = null;
    if (isHost) {
      fetch('/get-code').then(r => r.ok ? r.text() : '').then(code => { window.gameCode = code || null; });
    }
    socket.emit('join_room', { gameId, playerId });

    // Render initial leaderboard state before real-time updates arrive
    updateLeaderboard(allPlayers, gameMode);
    const drawerTable = document.querySelector('#drawer-leaderboard');
    if (drawerTable) {
      updateDrawerLeaderboard(allPlayers, gameMode);
    }

    const nextFrame = window.requestAnimationFrame ? (cb) => window.requestAnimationFrame(cb) : (cb) => setTimeout(cb, 16);
    const TILE_FONT_MIN_PX = 10;
    const TILE_FONT_STEP = 0.5;
    const TILE_FONT_MAX_ITERATIONS = 40;

    function debounce(fn, wait = 150) {
      let timeout;
      return function(...args) {
        clearTimeout(timeout);
        timeout = setTimeout(() => fn.apply(this, args), wait);
      };
    }

    function fitTileText(tile) {
      if (!tile) return;
      tile.classList.remove('tile-scroll');
      tile.style.fontSize = '';
      const computed = window.getComputedStyle(tile);
      let size = parseFloat(computed.fontSize) || 16;
      const minSize = Math.max(TILE_FONT_MIN_PX, size * 0.55);
      tile.style.fontSize = `${size}px`;
      let iterations = 0;
      while ((tile.scrollHeight > tile.clientHeight || tile.scrollWidth > tile.clientWidth) &&
        size > minSize &&
        iterations < TILE_FONT_MAX_ITERATIONS) {
        size -= TILE_FONT_STEP;
        tile.style.fontSize = `${size}px`;
        iterations++;
      }
      if (tile.scrollHeight > tile.clientHeight || tile.scrollWidth > tile.clientWidth) {
        tile.style.fontSize = `${minSize}px`;
        if (tile.scrollHeight > tile.clientHeight) {
          tile.classList.add('tile-scroll');
        }
      }
    }

    function fitTiles(scope) {
      const root = scope && typeof scope.querySelectorAll === 'function' ? scope : document;
      const tiles = root.querySelectorAll('.tile-content');
      tiles.forEach(fitTileText);
    }

    function scheduleTileResize(scope) {
      nextFrame(() => fitTiles(scope || document));
    }

    const debouncedTileResize = debounce(() => fitTiles(document), 200);
    window.addEventListener('resize', debouncedTileResize);

    // Update state
    socket.on('update_state', (data) => {
      const { game, players } = data;
      allPlayers = players; // Update global
      document.body.dataset.timerEnabled = game.timerEnabled ? 'true' : 'false';
      document.body.dataset.timerDuration = (game.timerDuration || 0).toString();
      document.body.dataset.timerStatus = game.timerStatus || 'not_started';
      document.body.dataset.timerStartedAt = game.timerStartedAt ? new Date(game.timerStartedAt).toISOString() : '';
      if (window.gameTimer) {
        window.gameTimer.syncWithGame(game);
      }
      const currentCardTable = document.getElementById(`card-${playerId}`);
      const currentPlayerData = players.find(p => String(p.id) === String(playerId));

      if (currentPlayerData) {
        if (game.mode === 'VS') {
          // VS Mode: Update colored stamps based on all players
          currentPlayerData.card.forEach((row, r) => {
            row.forEach((tile, c) => {
              const td = currentCardTable.rows[r].cells[c];
              td.querySelector('.tile-content').textContent = translateItemText(tile.item);

              // Clear all stamp classes
              td.className = '';
              td.dataset.row = r;
              td.dataset.col = c;

              // Check which player (if any) has stamped this square
              let stampedBy = null;
              for (const player of players) {
                const squares = player.stampedSquares || [];
                if (squares.some(s => Number(s.row) === r && Number(s.col) === c)) {
                  stampedBy = player.color;
                  break;
                }
              }

              if (stampedBy) {
                td.classList.add(`stamped-${stampedBy}`);
              }
            });
          });
        } else {
          // Regular mode: Original stamping logic
          currentPlayerData.card.forEach((row, r) => {
            row.forEach((tile, c) => {
              const td = currentCardTable.rows[r].cells[c];
              td.querySelector('.tile-content').textContent = translateItemText(tile.item);
              td.classList.toggle('stamped', tile.stamped);
            });
          });
        }
      }
      if (currentCardTable) {
        scheduleTileResize(currentCardTable);
      }
      updateLeaderboard(players, game.mode);
      // If mobile drawer leaderboard is open, refresh it
      if (document.getElementById('drawer-leaderboard')) {
        updateDrawerLeaderboard(players, game.mode);
      }
      
      if (game.status === 'ended' && !isGameOver) {
        isGameOver = true;
        document.getElementById('game-over').style.display = 'block';
        document.getElementById('winner-name').textContent = game.winner;
        if (isHost) {
          document.getElementById('host-options').style.display = 'block';
        }
      } else if (game.status === 'active' && isGameOver) {
        isGameOver = false;
        document.getElementById('game-over').style.display = 'none';
        if (isHost) {
          document.getElementById('host-options').style.display = 'none';
        }
      }

      // Update modal if open
      if (modalOpenPlayerId) {
        const updatedPlayer = players.find(p => String(p.id) === String(modalOpenPlayerId));
        if (updatedPlayer) {
          const modalCard = document.getElementById('modal-card');
          const isVsMode = game.mode === 'VS';
          const stampedLookup = new Map();
          if (isVsMode) {
            (updatedPlayer.stampedSquares || []).forEach(({ row, col, color }) => {
              stampedLookup.set(`${row},${col}`, color || '');
            });
          }
          modalCard.innerHTML = '';
          updatedPlayer.card.forEach((row, r) => {
            const tr = document.createElement('tr');
            row.forEach((tile, c) => {
              const td = document.createElement('td');
              const div = document.createElement('div');
              div.className = 'tile-content';
              div.textContent = translateItemText(tile.item);
              td.appendChild(div);
              const stampColor = stampedLookup.get(`${r},${c}`);
              const stamped = isVsMode ? Boolean(stampColor) : Boolean(tile.stamped);
              td.classList.toggle('stamped', stamped);
              if (isVsMode && stampColor) {
                td.classList.add(`stamped-${stampColor}`);
              }
              td.dataset.row = r;
              td.dataset.col = c;
              tr.appendChild(td);
            });
            modalCard.appendChild(tr);
          });
          scheduleTileResize(modalCard);
        }
      }
    });
    
    // Replace native alert with custom modal
    socket.on('win', ({ playerName, winCondition }) => {
      showWinnerModal(playerName, winCondition);
    });

    // Listen for card reveal events from other windows
    socket.on('card_revealed', ({ playerId: revealedPlayerId }) => {
      if (String(revealedPlayerId) === String(playerId)) {
        const cover = document.getElementById('card-cover');
        if (cover) {
          cover.classList.add('hidden');
          localStorage.setItem('cardRevealed_' + gameId, 'true');
        }
      }

      const revealedPlayer = allPlayers.find((p) => String(p.id) === String(revealedPlayerId));
      if (revealedPlayer) {
        revealedPlayer.cardRevealed = true;
        updateLeaderboard(allPlayers, gameMode);
        if (document.getElementById('drawer-leaderboard')) {
          updateDrawerLeaderboard(allPlayers, gameMode);
        }
      }
    });
    // Flag selection modal logic
    const flagSelectModal = document.getElementById('flag-select-modal');
    const flagBtn = document.getElementById('flag-button');
    const flagBtnMobile = document.getElementById('flag-button-mobile');
    const flagConfirmBtn = document.getElementById('flag-confirm');
    const flagCancelBtn = document.getElementById('flag-cancel');
    const flagTargetSelect = document.getElementById('flag-target-select');
    const hasFlagModal = !!(flagSelectModal && flagConfirmBtn && flagCancelBtn && flagTargetSelect);
    function openFlagModal() {
      if (!hasFlagModal) return;
      const select = flagTargetSelect;
      select.innerHTML = `<option value="">${translateText('game.flagModal.placeholder')}</option>`;
      allPlayers.forEach(p => {
        if (String(p.id) !== String(playerId)) {
          const opt = document.createElement('option');
          opt.value = p.id;
          opt.textContent = p.name;
          select.appendChild(opt);
        }
      });
      flagSelectModal.style.display = 'flex';
    }
    if (hasFlagModal) {
      if (flagBtn) flagBtn.addEventListener('click', openFlagModal);
      if (flagBtnMobile) flagBtnMobile.addEventListener('click', openFlagModal);
      flagCancelBtn.addEventListener('click', () => { flagSelectModal.style.display = 'none'; });
      flagConfirmBtn.addEventListener('click', () => {
        const targetId = flagTargetSelect.value;
        if (!targetId) return alert(translateText('game.flagModal.subtitle'));
        socket.emit('throw_flag', { gameId, flaggerId: playerId, targetPlayerId: targetId });
        flagSelectModal.style.display = 'none';
      });
    }
    
    // Stamp on click (only own card)
    document.querySelectorAll('#card-<%= currentPlayer.id %> td').forEach(td => {
      td.addEventListener('click', (e) => {
        if (isGameOver || td.closest('table').classList.contains('reroll-mode')) return;

        const row = td.dataset.row;
        const col = td.dataset.col;

        // Animate hanko press centered on tile
        (function animateHankoPress(el) {
          const rect = el.getBoundingClientRect();
          const tableEl = el.closest('table');
          tableEl.classList.add('no-cursor');
          const stamp = document.createElement('div');
          stamp.className = 'hanko-press';
          // Size the stamp to 80% of the tile
          stamp.style.width = (rect.width * 0.8) + 'px';
          stamp.style.height = (rect.height * 0.8) + 'px';
          // Position at center of tile, adjusted for page scroll
          const x = rect.left + window.scrollX + (rect.width / 2);
          const y = rect.top + window.scrollY + (rect.height / 2);
          stamp.style.left = x + 'px';
          stamp.style.top = y + 'px';
          document.body.appendChild(stamp);
          stamp.addEventListener('animationend', () => {
            stamp.remove();
            tableEl.classList.remove('no-cursor');
          });
        })(td);

        socket.emit('stamp', { gameId, playerId, row, col });
      });
    });
    scheduleTileResize(document.getElementById('card-<%= currentPlayer.id %>'));
    // Card reveal function
    function revealCard() {
      const cover = document.getElementById('card-cover');
      if (cover) {
        cover.classList.add('hidden');
        // Store reveal state in localStorage so it syncs across windows
        localStorage.setItem('cardRevealed_' + gameId, 'true');
        // Emit socket event to sync with all windows including OBS Browser Source
        socket.emit('card_revealed');
      }
    }

    // Check if card was already revealed
    const wasRevealed = localStorage.getItem('cardRevealed_' + gameId);
    if (wasRevealed === 'true') {
      const cover = document.getElementById('card-cover');
      if (cover) {
        cover.classList.add('hidden');
      }
    }

    function startNewGame() {
      socket.emit('new_game', { gameId });
      document.body.dataset.timerStatus = 'not_started';
      document.body.dataset.timerStartedAt = '';
      if (window.gameTimer) {
        window.gameTimer.resetToInitial();
      }
      // Reset card cover
      localStorage.removeItem('cardRevealed_' + gameId);
      const cover = document.getElementById('card-cover');
      if (cover) {
        cover.classList.remove('hidden');
      }
      // Close winner modal
      const winnerModal = document.getElementById('winner-modal');
      if (winnerModal) {
        winnerModal.style.display = 'none';
      }
      // Close timer expired modal
      const timerModal = document.getElementById('timer-expired-modal');
      if (timerModal) {
        timerModal.style.display = 'none';
      }
    }

    function copyGameCode() {
      function showSuccess() {
        const confirmEl = document.getElementById('copy-confirm');
        if (confirmEl) {
          confirmEl.style.visibility = 'visible';
          confirmEl.style.color = '#4CAF50';
          confirmEl.textContent = translateText('notifications.codeCopied');
          setTimeout(() => { confirmEl.style.visibility = 'hidden'; }, 3000);
        }
        const toast = document.getElementById('copy-toast-mobile');
        if (toast) {
          toast.textContent = translateText('notifications.codeCopied');
          toast.style.display = 'block';
          setTimeout(() => { toast.style.display = 'none'; }, 2000);
        }
      }
      function showFailWithPrompt(code) {
        // As a last resort, show a prompt the user can long-press/copy from
        try { window.prompt(translateText('game.copyPrompt'), code || ''); } catch (e) {}
        const toast = document.getElementById('copy-toast-mobile');
        if (toast) {
          toast.textContent = translateText('notifications.codeShown');
          toast.style.display = 'block';
          setTimeout(() => { toast.style.display = 'none'; }, 2000);
        }
      }
      function execCopySync(text) {
        try {
          const input = document.getElementById('hidden-copy-input');
          input.value = text || '';
          input.focus();
          input.select();
          input.setSelectionRange(0, input.value.length);
          return document.execCommand('copy');
        } catch (e) { return false; }
      }

      const doCopy = (code) => {
        if (!code) return showFailWithPrompt('');
        // Prefer synchronous execCommand to satisfy Safari gesture requirements
        if (execCopySync(code)) return showSuccess();
        // Try modern API as secondary
        if (navigator.clipboard && window.isSecureContext) {
          navigator.clipboard.writeText(code)
            .then(showSuccess)
            .catch(() => showFailWithPrompt(code));
        } else {
          showFailWithPrompt(code);
        }
      };

      if (window.gameCode) {
        doCopy(window.gameCode);
      } else {
        // Fallback: fetch then attempt copy; if blocked, show prompt
        fetch('/get-code')
          .then(res => res.ok ? res.text() : '')
          .then(code => { window.gameCode = code || null; doCopy(window.gameCode); })
          .catch(() => showFailWithPrompt(window.gameCode));
      }
    }

    function showPlayerCard(targetPlayerId) {
      modalOpenPlayerId = targetPlayerId;
      const player = allPlayers.find(p => String(p.id) === String(targetPlayerId));
      if (!player) return;
      const isCurrentPlayerView = String(targetPlayerId) === String(playerId);
      if (!player.cardRevealed && !isCurrentPlayerView) {
        openCardHiddenModal();
        return;
      }

      const isVsMode = gameMode === 'VS';
      const stampedLookup = new Map();
      if (isVsMode) {
        (player.stampedSquares || []).forEach(({ row, col, color }) => {
          stampedLookup.set(`${row},${col}`, color || '');
        });
      }

      document.getElementById('modal-player-name').textContent = translateText('game.playerCardTitle', { name: player.name });
      const modalCard = document.getElementById('modal-card');
      modalCard.innerHTML = '';
      player.card.forEach((row, r) => {
        const tr = document.createElement('tr');
        row.forEach((tile, c) => {
          const td = document.createElement('td');
          const div = document.createElement('div');
          div.className = 'tile-content';
          div.textContent = translateItemText(tile.item);
          td.appendChild(div);
          const stampColor = stampedLookup.get(`${r},${c}`);
          const stamped = isVsMode ? Boolean(stampColor) : Boolean(tile.stamped);
          td.classList.toggle('stamped', stamped);
          if (isVsMode && stampColor) {
            td.classList.add(`stamped-${stampColor}`);
          }
          td.dataset.row = r;
          td.dataset.col = c;
          tr.appendChild(td);
        });
        modalCard.appendChild(tr);
      });

      const modalReroll = document.getElementById('modal-reroll');
      modalReroll.style.display = isHost ? 'block' : 'none';
      if (isHost) {
        // Reset modal reroll controls for a fresh start
        const typeSelect = document.getElementById('modal-reroll-type');
        typeSelect.value = '';
    const randomBtn = document.getElementById('select-random-modal-button');
    randomBtn.style.display = 'none';
    randomBtn.textContent = translateText('game.reroll.randomButtonDefault');
        const instruct = document.getElementById('modal-selection-instruct');
        instruct.style.display = 'none';
        clearModalSelection();
        const modalTable = document.getElementById('modal-card');
        modalTable.classList.remove('reroll-mode');
        if (modalRerollState.clickListener) modalTable.removeEventListener('click', modalRerollState.clickListener);
        modalRerollState = { type: '', arg: '', selectedCells: [], clickListener: null };
        // Bind re-roll for modal
        modalReroll.dataset.targetPlayerId = targetPlayerId;
        document.getElementById('modal-reroll-type').onchange = () => handleModalTypeChange();
        document.getElementById('modal-confirm-reroll').onclick = () => confirmModalReroll();
      }

      document.getElementById('player-modal').style.display = 'block';
      scheduleTileResize(modalCard);
    }

    function openCardHiddenModal() {
      const modal = document.getElementById('card-hidden-modal');
      if (modal) {
        modal.style.display = 'flex';
      }
    }

    function closeCardHiddenModal() {
      const modal = document.getElementById('card-hidden-modal');
      if (modal) {
        modal.style.display = 'none';
      }
    }

    function closeModal() {
      document.getElementById('player-modal').style.display = 'none';
      modalOpenPlayerId = null;
      exitModalReroll();
    }

    // Modal re-roll functions
    let modalRerollState = {
      type: '',
      arg: '',
      selectedCells: [],
      clickListener: null
    };

    function handleModalTypeChange() {
      const select = document.getElementById('modal-reroll-type');
      const type = select.value;
      modalRerollState.type = type;
      clearModalSelection();

      const instruct = document.getElementById('modal-selection-instruct');
      const randomBtn = document.getElementById('select-random-modal-button');
      if (type === 'card') {
        instruct.style.display = 'none';
        randomBtn.style.display = 'none';
        selectModalCard();
      } else if (type === 'random') {
        instruct.style.display = 'none';
        randomBtn.style.display = 'block';
    randomBtn.textContent = translateText('game.reroll.randomButton');
        randomBtn.onclick = () => selectModalRandomTile();
      } else if (type === 'random_row') {
        instruct.style.display = 'none';
        randomBtn.style.display = 'block';
    randomBtn.textContent = translateText('game.reroll.randomRowButton');
        randomBtn.onclick = () => selectModalRandomRow();
      } else if (type === 'random_column') {
        instruct.style.display = 'none';
        randomBtn.style.display = 'block';
    randomBtn.textContent = translateText('game.reroll.randomColumnButton');
        randomBtn.onclick = () => selectModalRandomColumn();
      } else if (type === 'random_diagonal') {
        instruct.style.display = 'none';
        randomBtn.style.display = 'block';
    randomBtn.textContent = translateText('game.reroll.randomDiagonalButton');
        randomBtn.onclick = () => selectModalRandomDiagonal();
      } else if (type) {
        instruct.style.display = 'block';
        randomBtn.style.display = 'none';
      } else {
        instruct.style.display = 'none';
        randomBtn.style.display = 'none';
      }

      const table = document.getElementById('modal-card');
      table.classList.add('reroll-mode');
      if (modalRerollState.clickListener) table.removeEventListener('click', modalRerollState.clickListener);
      const handleClick = (e) => handleModalCardClick(e);
      modalRerollState.clickListener = handleClick;
      table.addEventListener('click', handleClick);
    }

    function handleModalCardClick(e) {
      let td = e.target.closest('td');
      if (!td) return;

      const state = modalRerollState;
      if (!state || !state.type || state.type === 'card') return;

      const row = parseInt(td.dataset.row, 10);
      const col = parseInt(td.dataset.col, 10);
      if (
        Number.isNaN(row) ||
        Number.isNaN(col) ||
        row < 0 || row >= boardSize ||
        col < 0 || col >= boardSize
      ) {
        return;
      }

      clearModalSelection();

      let positions = [];
      let arg = '';

      switch (state.type) {
        case 'tile':
          positions = [[row, col]];
          arg = `${row + 1},${col + 1}`;
          break;
        case 'row':
          positions = Array.from({ length: boardSize }, (_, c) => [row, c]);
          arg = `${row + 1}`;
          break;
        case 'column':
          positions = Array.from({ length: boardSize }, (_, r) => [r, col]);
          arg = `${col + 1}`;
          break;
        case 'diagonal':
          const isMain = row === col;
          const isAnti = row + col === lastBoardIndex;
          if (!isMain && !isAnti) return;
          if (isMain && isAnti) { // Center
            arg = 'main';
            positions = Array.from({ length: boardSize }, (_, i) => [i, i]);
          } else if (isMain) {
            arg = 'main';
            positions = Array.from({ length: boardSize }, (_, i) => [i, i]);
          } else if (isAnti) {
            arg = 'anti';
            positions = Array.from({ length: boardSize }, (_, i) => [i, lastBoardIndex - i]);
          }
          break;
      }

      if (positions.length > 0) {
        state.arg = arg;
        state.selectedCells = positions;
        highlightModalSelection(positions);
      }
    }

    function selectModalCard() {
      const positions = Array.from({ length: totalTiles }, (_, i) => [Math.floor(i / boardSize), i % boardSize]);
      modalRerollState.arg = '';
      modalRerollState.selectedCells = positions;
      highlightModalSelection(positions);
    }

    function highlightModalSelection(positions) {
      const table = document.getElementById('modal-card');
      positions.forEach(([r, c]) => {
        table.rows[r].cells[c].classList.add('selected');
      });
    }

    function clearModalSelection() {
      const state = modalRerollState;
      const table = document.getElementById('modal-card');
      state.selectedCells.forEach(([r, c]) => {
        if (table.rows[r] && table.rows[r].cells[c]) {
          table.rows[r].cells[c].classList.remove('selected');
        }
      });
      state.selectedCells = [];
      state.arg = '';
    }

    // Add helper for random tile selection in modal
    function selectModalRandomTile() {
      const state = modalRerollState;
      clearModalSelection();
      const r = Math.floor(Math.random() * boardSize);
      const c = Math.floor(Math.random() * boardSize);
      state.arg = `${r+1},${c+1}`;
      state.selectedCells = [[r, c]];
      highlightModalSelection(state.selectedCells);
    }
    function selectModalRandomRow() {
      const state = modalRerollState;
      clearModalSelection();
      const r = Math.floor(Math.random() * boardSize);
      state.arg = `${r + 1}`;
      state.selectedCells = Array.from({ length: boardSize }, (_, c) => [r, c]);
      highlightModalSelection(state.selectedCells);
    }
    function selectModalRandomColumn() {
      const state = modalRerollState;
      clearModalSelection();
      const c = Math.floor(Math.random() * boardSize);
      state.arg = `${c + 1}`;
      state.selectedCells = Array.from({ length: boardSize }, (_, r) => [r, c]);
      highlightModalSelection(state.selectedCells);
    }
    function selectModalRandomDiagonal() {
      const state = modalRerollState;
      clearModalSelection();
      const isMain = Math.random() < 0.5;
      state.arg = isMain ? 'main' : 'anti';
      state.selectedCells = isMain
        ? Array.from({ length: boardSize }, (_, i) => [i, i])
        : Array.from({ length: boardSize }, (_, i) => [i, lastBoardIndex - i]);
      highlightModalSelection(state.selectedCells);
    }

    function confirmModalReroll() {
      const state = modalRerollState;
      if (!state || !state.type) {
        alert(translateText('alerts.rerollMissingSelection'));
        return;
      }
      const requiresArg = ['tile', 'row', 'column', 'diagonal'];
      if (requiresArg.includes(state.type) && !state.arg && state.type !== 'card') {
        alert(translateText('alerts.rerollMissingSelection'));
        return;
      }

      const targetPlayerId = document.getElementById('modal-reroll').dataset.targetPlayerId;
      const emitType = state.type === 'random' ? 'tile' : state.type;
      window.socket.emit('reroll', {
        gameId,
        targetPlayerId,
        type: emitType,
        arg: state.arg
      });

      exitModalReroll();
    }

    function exitModalReroll() {
      const table = document.getElementById('modal-card');
      table.classList.remove('reroll-mode');
      if (modalRerollState.clickListener) table.removeEventListener('click', modalRerollState.clickListener);
      clearModalSelection();
      modalRerollState = { type: '', arg: '', selectedCells: [], clickListener: null };
      document.getElementById('modal-reroll-type').value = '';
    }

    // Drawer functions
    function toggleDrawer(contentType) {
      const drawer = document.getElementById('drawer');
      const drawerContent = drawer.querySelector('.drawer-content');
      drawerContent.innerHTML = '';
      if (drawer.style.bottom === '0px') {
        closeDrawer();
      } else {
        if (contentType === 'leaderboard') {
          const table = document.createElement('table');
          table.id = 'drawer-leaderboard';
          table.innerHTML = `
            <thead>
              <tr>
                <th>${translateText('game.leaderboardRank')}</th>
                <th>${translateText('game.leaderboardPlayer')}</th>
                <th>${translateText('game.leaderboardLines')}</th>
                <th>${translateText('game.leaderboardTiles')}</th>
              </tr>
            </thead>
            <tbody></tbody>
          `;
          drawerContent.appendChild(table);
          updateDrawerLeaderboard(allPlayers, gameMode);
        } // Add more for other types if needed
        drawer.style.bottom = '0px';
      }
    }

    function closeDrawer() {
      document.getElementById('drawer').style.bottom = '-100%';
    }

    function updateDrawerLeaderboard(players, gameMode) {
      const leaderboardBody = document.querySelector('#drawer-leaderboard tbody');
      if (!leaderboardBody) return;
      leaderboardBody.innerHTML = ''; // Clear existing
      const size = boardSize;
      const lastIndex = lastBoardIndex;
      const getTile = (cardData, row, col) => {
        if (!Array.isArray(cardData)) return undefined;
        const rowData = Array.isArray(cardData[row]) ? cardData[row] : [];
        return rowData[col];
      };

      // Compute scores (same as main leaderboard)
      const scoredPlayers = players.map(player => {
        let score = 0;
        let stampedCount = 0;

        if (gameMode === 'VS') {
          const squares = player.stampedSquares || [];
          stampedCount = squares.length;

          let stampedGrid = Array.from({ length: size }, () => Array(size).fill(false));
          squares.forEach(({ row, col }) => {
            const rIndex = Number(row);
            const cIndex = Number(col);
            if (!Number.isNaN(rIndex) && !Number.isNaN(cIndex) && rIndex >= 0 && rIndex < size && cIndex >= 0 && cIndex < size) {
              stampedGrid[rIndex][cIndex] = true;
            }
          });

          score += stampedGrid.filter(row => row.every(cell => cell)).length;

          for (let col = 0; col < size; col++) {
            let complete = true;
            for (let row = 0; row < size; row++) {
              if (!stampedGrid[row][col]) {
                complete = false;
                break;
              }
            }
            if (complete) score++;
          }

          let mainComplete = true;
          let antiComplete = true;
          for (let i = 0; i < size; i++) {
            if (!stampedGrid[i][i]) mainComplete = false;
            if (!stampedGrid[i][lastIndex - i]) antiComplete = false;
          }
          if (mainComplete) score++;
          if (antiComplete) score++;
        } else {
          const card = Array.isArray(player.card) ? player.card : [];
          card.forEach(row => {
            if (!Array.isArray(row)) return;
            row.forEach(tile => {
              if (tile && tile.stamped) stampedCount++;
            });
          });

          score += card.filter(row => Array.isArray(row) && row.length && row.every(t => t && t.stamped)).length;

          for (let col = 0; col < size; col++) {
            let complete = true;
            for (let row = 0; row < size; row++) {
              const tile = getTile(card, row, col);
              if (!tile || !tile.stamped) {
                complete = false;
                break;
              }
            }
            if (complete) score++;
          }

          let mainComplete = true;
          let antiComplete = true;
          for (let i = 0; i < size; i++) {
            const mainTile = getTile(card, i, i);
            const antiTile = getTile(card, i, lastIndex - i);
            if (!mainTile || !mainTile.stamped) mainComplete = false;
            if (!antiTile || !antiTile.stamped) antiComplete = false;
          }
          if (mainComplete) score++;
          if (antiComplete) score++;
        }

        return { id: player.id, name: player.name, score, stampedCount, color: player.color, cardRevealed: player.cardRevealed };
      });

      scoredPlayers.sort((a, b) => b.score - a.score || b.stampedCount - a.stampedCount);

    scoredPlayers.forEach((p, index) => {
      const tr = document.createElement('tr');
      const colorBadge = gameMode === 'VS' && p.color ? `<span class="color-badge ${p.color}"></span>` : '';
    const isSelf = String(p.id) === String(playerId);
    const canViewCard = !isSelf && Boolean(p.cardRevealed);
    const nameContent = isSelf
      ? p.name
      : (canViewCard ? `<span style="cursor: pointer; text-decoration: underline;" onclick="showPlayerCard('${p.id}')">${p.name}</span>` : p.name);
    const nameTd = `<td>${colorBadge}${nameContent}</td>`;
        tr.innerHTML = `
          <td>${index + 1}</td>
          ${nameTd}
          <td>${p.score}</td>
          <td>${p.stampedCount}</td>
        `;
        leaderboardBody.appendChild(tr);
      });
    }
    // Swipe to close drawer on mobile via downward swipe gesture
    (function() {
      const drawerEl = document.getElementById('drawer');
      let drawerStartY = null;
      drawerEl.addEventListener('touchstart', function(e) {
        // Only start if drawer is open
        if (drawerEl.style.bottom === '0px') {
          drawerStartY = e.touches[0].clientY;
        }
      });
      drawerEl.addEventListener('touchmove', function(e) {
        if (drawerStartY === null) return;
        const touchY = e.touches[0].clientY;
        const delta = touchY - drawerStartY;
        if (delta > 50) {
          closeDrawer();
          drawerStartY = null;
        }
      });
    })();
  // Show/Hide functions for winner modal
  function showWinnerModal(playerName, winCondition) {
    const modal = document.getElementById('winner-modal');
    document.getElementById('winner-modal-name').textContent = `${playerName} Wins!`;

    if (winCondition) {
      document.getElementById('winner-modal-condition').textContent = `with ${winCondition}`;
    } else {
      document.getElementById('winner-modal-condition').textContent = '';
    }

    modal.style.display = 'flex';
  }
  function closeWinnerModal() {
    document.getElementById('winner-modal').style.display = 'none';
  }

  // Chat functionality
  (function() {
    const chatPanel = document.getElementById('chat-panel');
    const chatToggleDesktop = document.getElementById('chat-toggle-desktop');
    const chatToggleMobile = document.getElementById('chat-toggle-mobile');
    const chatCloseDesktop = document.getElementById('chat-close-desktop');
    const chatSend = document.getElementById('chat-send');
    const chatInput = document.getElementById('chat-input');
    const chatMessages = document.getElementById('chat-messages');
    const chatNotification = document.getElementById('chat-notification');
    const chatNotificationMobile = document.getElementById('chat-notification-mobile');
    const { players: chatPlayers, messages: chatHistory } = window.bootstrapGameData || { players: [], messages: [] };
    const chatColors = {};
    const availableColors = ['#A3E635','#60A5FA','#F472B6','#FBBF24','#34D399','#F87171','#C084FC','#FCD34D','#38BDF8','#A78BFA'];
    chatPlayers.forEach((p,i) => { chatColors[p.id] = availableColors[i % availableColors.length]; });
    const chatNames = {};
    chatPlayers.forEach(p => { chatNames[p.id] = p.name; });

    function addChatMessage(msg) {
      const resolvedName = msg.playerName || (msg.player && msg.player.name);
      if (resolvedName && !chatNames[msg.playerId]) {
        chatNames[msg.playerId] = resolvedName;
      }
      const isSelf = String(msg.playerId) === String(playerId);
      const rowEl = document.createElement('div');
      rowEl.classList.add('chat-row', isSelf ? 'self' : 'other');

      const bubble = document.createElement('div');
      bubble.classList.add('chat-bubble', isSelf ? 'self' : 'other');
      bubble.style.backgroundColor = chatColors[msg.playerId] || '#ddd';
      // name header
      const header = document.createElement('div');
      header.classList.add('bubble-header');
      const nameFromPayload = resolvedName || chatNames[msg.playerId];
      const senderName = isSelf ? translateText('game.chatYou') : (nameFromPayload || translateText('game.chatUnknown'));
      header.textContent = senderName;
      bubble.appendChild(header);
      // message content
      const content = document.createElement('div');
      content.classList.add('bubble-content');
      content.textContent = msg.content;
      bubble.appendChild(content);
      // timestamp
      const time = document.createElement('div');
      time.classList.add('bubble-time');
      time.textContent = new Date(msg.createdAt).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
      bubble.appendChild(time);
      rowEl.appendChild(bubble);
      chatMessages.appendChild(rowEl);
      chatMessages.scrollTop = chatMessages.scrollHeight;
    }

    chatHistory.forEach(addChatMessage);

    const setChatNotificationVisibility = (visible) => {
      [chatNotification, chatNotificationMobile].forEach(el => {
        if (!el) return;
        el.classList.toggle('is-visible', Boolean(visible));
      });
    };

    const toggleChatPanel = () => {
      chatPanel.classList.toggle('open');
      if (chatPanel.classList.contains('open')) {
        setChatNotificationVisibility(false);
      }
    };

    setChatNotificationVisibility(false);

    if (chatToggleDesktop) {
      chatToggleDesktop.addEventListener('click', toggleChatPanel);
    }
    if (chatToggleMobile) {
      chatToggleMobile.addEventListener('click', toggleChatPanel);
    }
    if (chatCloseDesktop) {
      chatCloseDesktop.addEventListener('click', () => {
        chatPanel.classList.remove('open');
        setChatNotificationVisibility(false);
      });
    }

    chatSend.addEventListener('click', () => {
      const content = chatInput.value.trim();
      if (!content) return;
      socket.emit('chat_message', { gameId, playerId, content });
      chatInput.value = '';
    });
    chatInput.addEventListener('keydown', e => {
      if (e.key === 'Enter') { e.preventDefault(); chatSend.click(); }
    });

    socket.on('new_message', ({ message, playerName }) => {
      addChatMessage({ ...message, playerName });
      if (!chatPanel.classList.contains('open')) {
        setChatNotificationVisibility(true);
      }
    });
  })();
  </script>
  <script src="/js/vote.js"></script>
  <script>
    function setStreamerLabel(button, isOn) {
      if (!button) return;
      const label = button.querySelector('[data-streamer-state]') || button;
      label.textContent = isOn ? translateText('game.streamerModeOn') : translateText('game.streamerModeOff');
      label.dataset.streamerState = isOn ? 'on' : 'off';
    }
    function toggleStreamerMode() {
      document.body.classList.toggle('streamer-mode');
      const btn = document.getElementById('streamer-toggle-btn');
      setStreamerLabel(btn, document.body.classList.contains('streamer-mode'));
    }
    /** Toggle streamer mode for non-host players */
    function toggleStreamerModeNonHost() {
      document.body.classList.toggle('streamer-mode');
      const btnNH = document.getElementById('streamer-toggle-btn-nonhost');
      setStreamerLabel(btnNH, document.body.classList.contains('streamer-mode'));
    }

    function setMinimalLabel(button, isOn) {
      if (!button) return;
      const label = button.querySelector('[data-minimal-state]') || button;
      label.textContent = isOn ? translateText('game.minimalModeOn') : translateText('game.minimalModeOff');
      label.dataset.minimalState = isOn ? 'on' : 'off';
    }
    function syncMinimalControls(isOn) {
      setMinimalLabel(document.getElementById('minimal-toggle-btn'), isOn);
      setMinimalLabel(document.getElementById('minimal-toggle-btn-nonhost'), isOn);
    }
    function applyMinimalModeState(shouldEnable) {
      document.body.classList.toggle('minimal-mode', shouldEnable);
      syncMinimalControls(document.body.classList.contains('minimal-mode'));
    }
    function toggleMinimalMode(forceState) {
      const desiredState = typeof forceState === 'boolean'
        ? forceState
        : !document.body.classList.contains('minimal-mode');
      applyMinimalModeState(desiredState);
    }
    function toggleMinimalModeNonHost() {
      toggleMinimalMode();
    }
    function exitMinimalMode() {
      toggleMinimalMode(false);
    }
    applyMinimalModeState(document.body.classList.contains('minimal-mode'));

    function popoutCard() {
      const gameId = document.body.dataset.gameId;
      const playerId = document.body.dataset.playerId;
      const theme = document.body.dataset.theme || 'light';
      const popoutUrl = `/game/${gameId}/popout?playerId=${playerId}&theme=${theme}`;
      const popoutWindow = window.open(popoutUrl, 'BingoCardPopout', 'width=600,height=600,resizable=yes,scrollbars=no');
      if (popoutWindow) {
        popoutWindow.focus();
      } else {
        alert(translateText('alerts.popupBlocked') || 'Popup blocked! Please allow popups for this site.');
      }
    }
    function openStreamInstructions() {
      const modal = document.getElementById('stream-instructions-modal');
      if (!modal) return;
      modal.style.display = 'flex';
      document.body.classList.add('modal-open');
      const title = document.getElementById('stream-instructions-title');
      if (title && typeof title.focus === 'function') {
        title.focus();
      }
    }
    function closeStreamInstructions() {
      const modal = document.getElementById('stream-instructions-modal');
      if (!modal) return;
      modal.style.display = 'none';
      document.body.classList.remove('modal-open');
      const trigger = document.getElementById('stream-instructions-btn');
      if (trigger && typeof trigger.focus === 'function') {
        trigger.focus();
      }
    }

    (function initStreamInstructionsModal() {
      const modal = document.getElementById('stream-instructions-modal');
      if (!modal) return;
      modal.addEventListener('click', (event) => {
        if (event.target === modal) {
          closeStreamInstructions();
        }
      });
      document.addEventListener('keydown', (event) => {
        if (event.key === 'Escape' && modal.style.display === 'flex') {
          closeStreamInstructions();
        }
      });
    })();

    function openDeviceLinkModal() {
      const modal = document.getElementById('device-link-modal');
      if (!modal) return;
      deviceLinkState.modal = modal;
      modal.style.display = 'flex';
      document.body.classList.add('modal-open');
      deviceLinkState.warningAcknowledged = false;
      setDeviceLinkWarningVisible(true);
      resetDeviceLinkUI();
    }

    function closeDeviceLinkModal() {
      const modal = deviceLinkState.modal || document.getElementById('device-link-modal');
      if (!modal) return;
      modal.style.display = 'none';
      document.body.classList.remove('modal-open');
      setDeviceLinkWarningVisible(false);
      deviceLinkState.modal = null;
      if (deviceLinkState.expiryTimer) {
        clearInterval(deviceLinkState.expiryTimer);
        deviceLinkState.expiryTimer = null;
      }
    }

    function setDeviceLinkWarningVisible(visible) {
      const warning = document.getElementById('device-link-warning');
      if (warning) {
        warning.style.display = visible ? 'flex' : 'none';
      }
    }

    function acknowledgeDeviceLinkWarning() {
      deviceLinkState.warningAcknowledged = true;
      setDeviceLinkWarningVisible(false);
      requestDeviceLink();
    }

    function resetDeviceLinkUI() {
      const codeEl = document.getElementById('device-link-code');
      if (codeEl) codeEl.textContent = deviceLinkPlaceholderCode;
      const pinEl = document.getElementById('device-link-pin');
      if (pinEl) pinEl.textContent = deviceLinkPlaceholderPin;
      const urlInput = document.getElementById('device-link-url');
      if (urlInput) urlInput.value = '';
      const qrImg = document.getElementById('device-link-qr');
      const placeholder = document.getElementById('device-link-placeholder');
      if (qrImg) {
        qrImg.removeAttribute('src');
        qrImg.style.display = 'none';
      }
      if (placeholder) {
        placeholder.style.display = 'block';
      }
      setDeviceLinkStatus('');
      setDeviceLinkError('');
      updateDeviceLinkExpiry(null);
    }

    function setDeviceLinkLoading(isLoading) {
      deviceLinkState.loading = isLoading;
      const button = document.getElementById('device-link-refresh');
      if (button) {
        button.disabled = Boolean(isLoading);
        button.setAttribute('aria-busy', isLoading ? 'true' : 'false');
      }
    }

    function setDeviceLinkStatus(message) {
      const statusEl = document.getElementById('device-link-status');
      if (statusEl) {
        statusEl.textContent = message || '';
      }
    }

    function setDeviceLinkError(message) {
      const errorEl = document.getElementById('device-link-error');
      if (errorEl) {
        errorEl.textContent = message || '';
      }
    }

    function updateDeviceLinkUI(payload) {
      if (!payload) return;
      deviceLinkState.current = payload;
      const codeEl = document.getElementById('device-link-code');
      if (codeEl) {
        codeEl.textContent = payload.code || deviceLinkPlaceholderCode;
      }
      const pinEl = document.getElementById('device-link-pin');
      if (pinEl) {
        pinEl.textContent = payload.pin || deviceLinkPlaceholderPin;
      }
      const urlInput = document.getElementById('device-link-url');
      if (urlInput) {
        urlInput.value = payload.linkUrl || '';
      }
      const qrImg = document.getElementById('device-link-qr');
      const placeholder = document.getElementById('device-link-placeholder');
      if (payload.qrCode && qrImg) {
        qrImg.src = payload.qrCode;
        qrImg.style.display = 'block';
        if (placeholder) {
          placeholder.style.display = 'none';
        }
      } else if (qrImg) {
        qrImg.style.display = 'none';
        if (placeholder) {
          placeholder.style.display = 'block';
        }
      }
      setDeviceLinkStatus('');
      setDeviceLinkError('');
      startDeviceLinkExpiryTimer(payload.expiresAt);
    }

    function formatDeviceLinkDuration(ms) {
      const totalSeconds = Math.max(0, Math.floor(ms / 1000));
      const hours = Math.floor(totalSeconds / 3600);
      const minutes = Math.floor((totalSeconds % 3600) / 60);
      const seconds = totalSeconds % 60;
      if (hours > 0) {
        return `${hours}h ${minutes}m`;
      }
      if (minutes > 0) {
        return `${minutes}m ${seconds}s`;
      }
      return `${seconds}s`;
    }

    function updateDeviceLinkExpiry(expiresAt) {
      const expiryEl = document.getElementById('device-link-expiry');
      if (!expiryEl) return;
      if (!expiresAt) {
        expiryEl.textContent = '';
        return;
      }
      const expiryDate = expiresAt instanceof Date ? expiresAt : new Date(expiresAt);
      const diff = expiryDate.getTime() - Date.now();
      if (diff <= 0) {
        expiryEl.textContent = translateText('game.deviceLink.expired');
        return;
      }
      expiryEl.textContent = translateText('game.deviceLink.expiresIn', { time: formatDeviceLinkDuration(diff) });
    }

    function startDeviceLinkExpiryTimer(expiresAt) {
      if (deviceLinkState.expiryTimer) {
        clearInterval(deviceLinkState.expiryTimer);
        deviceLinkState.expiryTimer = null;
      }
      deviceLinkState.expiresAt = expiresAt ? new Date(expiresAt) : null;
      updateDeviceLinkExpiry(deviceLinkState.expiresAt);
      if (!deviceLinkState.expiresAt) {
        return;
      }
      deviceLinkState.expiryTimer = setInterval(() => {
        updateDeviceLinkExpiry(deviceLinkState.expiresAt);
        if (deviceLinkState.expiresAt && deviceLinkState.expiresAt.getTime() <= Date.now()) {
          clearInterval(deviceLinkState.expiryTimer);
          deviceLinkState.expiryTimer = null;
        }
      }, 30000);
    }

    async function requestDeviceLink() {
      if (!deviceLinkState.warningAcknowledged) {
        return;
      }
      if (deviceLinkState.loading) return;
      if (!csrfTokenValue) {
        setDeviceLinkError(translateText('game.deviceLink.securityError'));
        return;
      }
      setDeviceLinkLoading(true);
      setDeviceLinkStatus(translateText('game.deviceLink.loading'));
      setDeviceLinkError('');
      try {
        const response = await fetch('/api/device-links', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'x-csrf-token': csrfTokenValue
          },
          body: JSON.stringify({})
        });
        let payload = {};
        try {
          payload = await response.json();
        } catch (error) {
          payload = {};
        }
        if (!response.ok) {
          throw new Error(payload.error || translateText('game.deviceLink.error'));
        }
        updateDeviceLinkUI(payload);
      } catch (error) {
        console.error('Device link creation error:', error);
        setDeviceLinkError(error.message || translateText('game.deviceLink.error'));
      } finally {
        setDeviceLinkLoading(false);
        setDeviceLinkStatus('');
      }
    }

    function showDeviceLinkToast(message) {
      const toast = document.getElementById('copy-toast-mobile');
      if (!toast) return;
      toast.textContent = message;
      toast.style.display = 'block';
      setTimeout(() => {
        toast.style.display = 'none';
      }, 2000);
    }

    function copyDeviceLinkUrl() {
      const input = document.getElementById('device-link-url');
      if (!input || !input.value) {
        setDeviceLinkError(translateText('game.deviceLink.copyUnavailable'));
        return;
      }
      const value = input.value;
      const onSuccess = () => {
        const message = translateText('notifications.linkCopied');
        setDeviceLinkStatus(message);
        showDeviceLinkToast(message);
      };
      const fallbackCopy = () => {
        try {
          input.removeAttribute('readonly');
          input.select();
          document.execCommand('copy');
          input.setAttribute('readonly', 'readonly');
          input.blur();
          onSuccess();
        } catch (error) {
          setDeviceLinkError(translateText('game.deviceLink.copyUnavailable'));
        }
      };
      if (navigator.clipboard && window.isSecureContext) {
        navigator.clipboard.writeText(value).then(onSuccess).catch(fallbackCopy);
      } else {
        fallbackCopy();
      }
    }

    (function initDeviceLinkModal() {
      const modal = document.getElementById('device-link-modal');
      if (!modal) return;
      modal.addEventListener('click', (event) => {
        if (event.target === modal) {
          closeDeviceLinkModal();
        }
      });
      document.addEventListener('keydown', (event) => {
        if (event.key === 'Escape' && modal.style.display === 'flex') {
          closeDeviceLinkModal();
        }
      });
    })();

    function toggleHamburgerMenu() {
      const menu = document.getElementById('hamburger-menu');
      if (menu.style.display === 'none') {
        menu.style.display = 'block';
      } else {
        menu.style.display = 'none';
      }
    }

    function closeHamburgerOnMobile() {
      // Auto-close menu on mobile after clicking an option
      if (window.innerWidth <= 768) {
        const menu = document.getElementById('hamburger-menu');
        menu.style.display = 'none';
      }
    }

    // Close hamburger menu when clicking outside
    document.addEventListener('click', function(event) {
      const menu = document.getElementById('hamburger-menu');
      const toggle = document.querySelector('.hamburger-toggle');
      const container = document.querySelector('.hamburger-menu-container');

      if (menu && toggle && !container.contains(event.target)) {
        menu.style.display = 'none';
      }
    });
  </script>
</body>
</html>
